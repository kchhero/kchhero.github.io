From 63239836e1fc8c874a79e67f7155b8f7fd8f5494 Mon Sep 17 00:00:00 2001
From: suker <suker@nexell.co.kr>
Date: Tue, 28 Mar 2017 13:30:12 +0900
Subject: [PATCH] suker: lava-dispatcher nexell extension

---
 lava_dispatcher/pipeline/actions/boot/fastboot.py  | 218 ++++----
 lava_dispatcher/pipeline/actions/boot/lxc.py       |  75 ++-
 .../pipeline/actions/deploy/apply_overlay.py       | 448 +++++++---------
 .../pipeline/actions/deploy/fastboot.py            | 594 ++++++++++++++++-----
 lava_dispatcher/pipeline/actions/deploy/lxc.py     | 229 ++++----
 lava_dispatcher/pipeline/connections/lxc.py        | 129 ++++-
 lava_dispatcher/pipeline/connections/telnet.py     |  94 ++++
 lava_dispatcher/pipeline/protocols/lxc.py          |  67 +--
 lava_dispatcher/pipeline/utils/constants.py        |  50 +-
 9 files changed, 1126 insertions(+), 778 deletions(-)
 create mode 100644 lava_dispatcher/pipeline/connections/telnet.py

diff --git a/lava_dispatcher/pipeline/actions/boot/fastboot.py b/lava_dispatcher/pipeline/actions/boot/fastboot.py
index e5e9c7e..45c88f3 100644
--- a/lava_dispatcher/pipeline/actions/boot/fastboot.py
+++ b/lava_dispatcher/pipeline/actions/boot/fastboot.py
@@ -19,37 +19,16 @@
 # with this program; if not, see <http://www.gnu.org/licenses>.
 
 
-import os
 from lava_dispatcher.pipeline.action import (
+    Pipeline,
     Action,
-    ConfigurationError,
     JobError,
-    Pipeline,
 )
 from lava_dispatcher.pipeline.logical import Boot
-from lava_dispatcher.pipeline.actions.boot import (
-    BootAction,
-    AutoLoginAction,
-    WaitUSBDeviceAction,
-)
-from lava_dispatcher.pipeline.actions.deploy.lxc import LxcAddDeviceAction
-from lava_dispatcher.pipeline.actions.boot.environment import ExportDeviceEnvironment
-from lava_dispatcher.pipeline.protocols.lxc import LxcProtocol
-from lava_dispatcher.pipeline.shell import ExpectShellSession
-
-
-def _fastboot_sequence_map(sequence):
-    """Maps fastboot sequence with corresponding class."""
-    sequence_map = {'boot': (FastbootBootAction, None),
-                    'reboot': (FastbootRebootAction, None),
-                    'wait-usb-add': (WaitUSBDeviceAction, ['add']),
-                    'wait-usb-remove': (WaitUSBDeviceAction, ['remove']),
-                    'lxc-add-device': (LxcAddDeviceAction, None),
-                    'auto-login': (AutoLoginAction, None),
-                    'shell-session': (ExpectShellSession, None),
-                    'export-env': (ExportDeviceEnvironment, None), }
-    return sequence_map.get(sequence, (None, None))
-
+from lava_dispatcher.pipeline.actions.boot import BootAction
+from lava_dispatcher.pipeline.connections.lxc import ConnectLxc
+# Nexell extension
+from lava_dispatcher.pipeline.connections.telnet import ConnectTelnet
 
 class BootFastboot(Boot):
     """
@@ -69,8 +48,6 @@ class BootFastboot(Boot):
         if 'method' in parameters:
             if parameters['method'] == 'fastboot':
                 return True
-        if 'methods' not in device['actions']['boot']:
-            raise ConfigurationError("Device misconfiguration")
         return False
 
 
@@ -85,28 +62,76 @@ class BootFastbootAction(BootAction):
         self.summary = "fastboot boot"
         self.description = "fastboot boot into the system"
 
+    def populate(self, parameters):
+        self.internal_pipeline = Pipeline(parent=self, job=self.job, parameters=parameters)
+
+        # Nexell Extension
+        if len(parameters['nexell_ext']) > 0:
+            self.internal_pipeline.add_action(NexellFastbootBootAction(parameters))
+            self.internal_pipeline.add_action(ConnectTelnet(parameters))
+            self.internal_pipeline.add_action(WaitForAdbDeviceForNexell())
+        else:    
+            self.internal_pipeline.add_action(FastbootBootAction())
+            self.internal_pipeline.add_action(ConnectLxc())
+            self.internal_pipeline.add_action(WaitForAdbDevice())
+
+# Nexell extension
+class NexellFastbootBootAction(Action):
+    """
+    This action calls fastboot to boot into the system.
+    """
+    def __init__(self,parameters):
+        super(NexellFastbootBootAction, self).__init__()
+        self.name = "nexell-boot-on-uboot"
+        self.summary = "attempt to boot"
+        self.description = "nexell boot into system"
+        self.command = ''
+        self.cmd_script = parameters['nexell_ext']['command']
+        self.cmd_param = parameters['nexell_ext']['command_param']
+
     def validate(self):
-        super(BootFastbootAction, self).validate()
-        sequences = self.job.device['actions']['boot']['methods'].get(
-            'fastboot', [])
-        for sequence in sequences:
-            if not _fastboot_sequence_map(sequence):
-                self.errors = "Unknown boot sequence '%s'" % sequence
+        super(NexellFastbootBootAction, self).validate()
 
-    def populate(self, parameters):
-        self.internal_pipeline = Pipeline(parent=self, job=self.job,
-                                          parameters=parameters)
-        sequences = self.job.device['actions']['boot']['methods'].get(
-            'fastboot', [])
-        for sequence in sequences:
-            mapped = _fastboot_sequence_map(sequence)
-            if mapped[1]:
-                self.internal_pipeline.add_action(
-                    mapped[0](device_actions=mapped[1]))
-            elif mapped[0]:
-                self.internal_pipeline.add_action(mapped[0]())
+    def run(self, connection, args=None):
+        connection = super(NexellFastbootBootAction, self).run(connection, args)
+        cmd = [self.cmd_script, self.cmd_param]
+        command_output = self.run_command(cmd)
+        self.data['boot-result'] = 'success'
+        return connection
 
+# Nexell extension
+class WaitForAdbDeviceForNexell(Action):
+    """
+    Waits for device that gets connected using adb.
+    """
+
+    def __init__(self):
+        super(WaitForAdbDeviceForNexell, self).__init__()
+        self.name = "wait-for-adb-device-by-nexell"
+        self.summary = "Waits for adb device"
+        self.description = "Waits for availability of adb device"
+        self.prompts = []
 
+    def validate(self):
+        super(WaitForAdbDeviceForNexell, self).validate()
+        if 'adb_serial_number' not in self.job.device:
+            self.errors = "device adb serial number missing"
+            if self.job.device['adb_serial_number'] == '0000000000':
+                self.errors = "device adb serial number unset"
+                
+    def run(self, connection, args=None):
+        connection = super(WaitForAdbDeviceForNexell, self).run(connection, args)
+        adb_cmd = ['/opt/android-sdk-linux/platform-tools/adb', 'start-server']
+        serial_number = self.job.device['adb_serial_number']
+        self.logger.debug("Starting adb daemon")
+        self.run_command(adb_cmd)
+        adb_cmd = ['/opt/android-sdk-linux/platform-tools/adb', '-s', serial_number, 'wait-for-device']
+        self.logger.debug("%s: Nexell Waiting for device", serial_number)
+        self.run_command(adb_cmd)
+        
+        return connection
+    
+    
 class FastbootBootAction(Action):
     """
     This action calls fastboot to boot into the system.
@@ -117,6 +142,7 @@ class FastbootBootAction(Action):
         self.name = "boot-fastboot"
         self.summary = "attempt to fastboot boot"
         self.description = "fastboot boot into system"
+        self.command = ''
 
     def validate(self):
         super(FastbootBootAction, self).validate()
@@ -124,90 +150,52 @@ class FastbootBootAction(Action):
             self.errors = "device fastboot serial number missing"
             if self.job.device['fastboot_serial_number'] == '0000000000':
                 self.errors = "device fastboot serial number unset"
-        if 'fastboot_options' not in self.job.device:
-            self.errors = "device fastboot options missing"
-            if not isinstance(self.job.device['fastboot_options'], list):
-                self.errors = "device fastboot options is not a list"
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(FastbootBootAction, self).run(connection, max_end_time, args)
-        # this is the device namespace - the lxc namespace is not accessible
-        lxc_name = None
-        protocol = [protocol for protocol in self.job.protocols if protocol.name == LxcProtocol.name][0]
-        if protocol:
-            lxc_name = protocol.lxc_name
-        if not lxc_name:
-            self.errors = "Unable to use fastboot"
-            return connection
-        self.logger.debug("[%s] lxc name: %s", self.parameters['namespace'],
-                          lxc_name)
+
+    def run(self, connection, args=None):
+        connection = super(FastbootBootAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
         serial_number = self.job.device['fastboot_serial_number']
-        boot_img = self.get_namespace_data(action='download_action',
-                                           label='boot', key='file')
-        if not boot_img:
-            raise JobError("Boot image not found, unable to boot")
-        else:
-            boot_img = os.path.join('/', os.path.basename(boot_img))
         fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
-                        '-s', serial_number, 'boot',
-                        boot_img] + self.job.device['fastboot_options']
+                        '-s', serial_number, 'reboot']
         command_output = self.run_command(fastboot_cmd)
-        if command_output and 'booting' not in command_output:
+        if command_output and 'rebooting' not in command_output:
             raise JobError("Unable to boot with fastboot: %s" % command_output)
         else:
             status = [status.strip() for status in command_output.split(
                 '\n') if 'finished' in status][0]
             self.results = {'status': status}
-        res = 'failed' if self.errors else 'success'
-        self.set_namespace_data(action='boot', label='shared', key='boot-result', value=res)
+        self.data['boot-result'] = 'failed' if self.errors else 'success'
         return connection
 
 
-class FastbootRebootAction(Action):
+class WaitForAdbDevice(Action):
     """
-    This action calls fastboot to reboot into the system.
+    Waits for device that gets connected using adb.
     """
 
     def __init__(self):
-        super(FastbootRebootAction, self).__init__()
-        self.name = "fastboot-reboot"
-        self.summary = "attempt to fastboot reboot"
-        self.description = "fastboot reboot into system"
+        super(WaitForAdbDevice, self).__init__()
+        self.name = "wait-for-adb-device"
+        self.summary = "Waits for adb device"
+        self.description = "Waits for availability of adb device"
+        self.prompts = []
 
     def validate(self):
-        super(FastbootRebootAction, self).validate()
-        if 'fastboot_serial_number' not in self.job.device:
-            self.errors = "device fastboot serial number missing"
-            if self.job.device['fastboot_serial_number'] == '0000000000':
-                self.errors = "device fastboot serial number unset"
-        if 'fastboot_options' not in self.job.device:
-            self.errors = "device fastboot options missing"
-            if not isinstance(self.job.device['fastboot_options'], list):
-                self.errors = "device fastboot options is not a list"
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(FastbootRebootAction, self).run(connection, max_end_time, args)
-        # this is the device namespace - the lxc namespace is not accessible
-        lxc_name = None
-        protocol = [protocol for protocol in self.job.protocols if protocol.name == LxcProtocol.name][0]
-        if protocol:
-            lxc_name = protocol.lxc_name
-        if not lxc_name:
-            self.errors = "Unable to use fastboot"
-            return connection
-        self.logger.debug("[%s] lxc name: %s", self.parameters['namespace'],
-                          lxc_name)
-        serial_number = self.job.device['fastboot_serial_number']
-        fastboot_opts = self.job.device['fastboot_options']
-        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot', '-s',
-                        serial_number, 'reboot'] + fastboot_opts
-        command_output = self.run_command(fastboot_cmd)
-        if command_output and 'rebooting' not in command_output:
-            raise JobError("Unable to fastboot reboot: %s" % command_output)
-        else:
-            status = [status.strip() for status in command_output.split(
-                '\n') if 'finished' in status][0]
-            self.results = {'status': status}
-        res = 'failed' if self.errors else 'success'
-        self.set_namespace_data(action='boot', label='shared', key='boot-result', value=res)
+        super(WaitForAdbDevice, self).validate()
+        if 'adb_serial_number' not in self.job.device:
+            self.errors = "device adb serial number missing"
+            if self.job.device['adb_serial_number'] == '0000000000':
+                self.errors = "device adb serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(WaitForAdbDevice, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        serial_number = self.job.device['adb_serial_number']
+        adb_cmd = ['lxc-attach', '-n', lxc_name, '--', 'adb', 'start-server']
+        self.logger.debug("Starting adb daemon")
+        self.run_command(adb_cmd)
+        adb_cmd = ['lxc-attach', '-n', lxc_name, '--', 'adb',
+                   '-s', serial_number, 'wait-for-device']
+        self.logger.debug("%s: Waiting for device", serial_number)
+        self.run_command(adb_cmd)
         return connection
diff --git a/lava_dispatcher/pipeline/actions/boot/lxc.py b/lava_dispatcher/pipeline/actions/boot/lxc.py
index 075a0d9..3121ad1 100644
--- a/lava_dispatcher/pipeline/actions/boot/lxc.py
+++ b/lava_dispatcher/pipeline/actions/boot/lxc.py
@@ -18,7 +18,6 @@
 # along
 # with this program; if not, see <http://www.gnu.org/licenses>.
 
-import time
 from lava_dispatcher.pipeline.action import (
     Pipeline,
     Action,
@@ -29,8 +28,11 @@ from lava_dispatcher.pipeline.actions.boot import BootAction
 from lava_dispatcher.pipeline.actions.boot.environment import (
     ExportDeviceEnvironment,
 )
+from lava_dispatcher.pipeline.actions.boot import AutoLoginAction
+# Nexell extension
 from lava_dispatcher.pipeline.connections.lxc import (
     ConnectLxc,
+    ConnectNexell,
 )
 from lava_dispatcher.pipeline.shell import ExpectShellSession
 from lava_dispatcher.pipeline.utils.shell import infrastructure_error
@@ -70,12 +72,21 @@ class BootLxcAction(BootAction):
 
     def populate(self, parameters):
         self.internal_pipeline = Pipeline(parent=self, job=self.job, parameters=parameters)
-        self.internal_pipeline.add_action(LxcStartAction())
-        self.internal_pipeline.add_action(ConnectLxc())
-        # Skip AutoLoginAction unconditionally as this action tries to parse kernel message
-        # self.internal_pipeline.add_action(AutoLoginAction())
-        self.internal_pipeline.add_action(ExpectShellSession())
-        self.internal_pipeline.add_action(ExportDeviceEnvironment())
+        # Nexell extension
+        if parameters['nexell_ext'] :
+            self.internal_pipeline.add_action(NexellStartAction())
+            self.internal_pipeline.add_action(ConnectNexell())
+            self.internal_pipeline.add_action(AutoLoginAction())
+            self.internal_pipeline.add_action(ExpectShellSession())
+            self.internal_pipeline.add_action(ExportDeviceEnvironment())
+        else:
+            self.internal_pipeline.add_action(LxcStartAction())
+            self.internal_pipeline.add_action(ConnectLxc())
+            # Add AutoLoginAction unconditionally as this action does nothing if
+            # the configuration does not contain 'auto_login'
+            self.internal_pipeline.add_action(AutoLoginAction())
+            self.internal_pipeline.add_action(ExpectShellSession())
+            self.internal_pipeline.add_action(ExportDeviceEnvironment())
 
 
 class LxcStartAction(Action):
@@ -88,53 +99,39 @@ class LxcStartAction(Action):
         self.name = "boot-lxc"
         self.summary = "attempt to boot"
         self.description = "boot into lxc container"
-        self.sleep = 10
+        self.command = ''
 
     def validate(self):
         super(LxcStartAction, self).validate()
         self.errors = infrastructure_error('lxc-start')
 
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcStartAction, self).run(connection, max_end_time, args)
-        lxc_name = self.get_namespace_data(action='lxc-create-action', label='lxc', key='name')
-        lxc_cmd = ['lxc-start', '-n', lxc_name, '-d']
+    def run(self, connection, args=None):
+        connection = super(LxcStartAction, self).run(connection, args)
+        lxc_cmd = ['lxc-start', '-n', self.get_common_data('lxc', 'name'),
+                   '-d']
         command_output = self.run_command(lxc_cmd)
         if command_output and command_output is not '':
             raise JobError("Unable to start lxc container: %s" %
                            command_output)  # FIXME: JobError needs a unit test
-        lxc_cmd = ['lxc-attach', '-n', lxc_name, 'runlevel']
-        self.logger.debug("Waiting for '%s' to become ready", lxc_name)
-        while True:
-            command_output = self.run_command(lxc_cmd, allow_fail=True)
-            if command_output and command_output not in ['unknown', 'S']:
-                break
-            time.sleep(self.sleep)  # poll every 10 seconds.
-        self.logger.info("'%s' is ready", lxc_name)
         return connection
 
-
-class LxcStopAction(Action):
+class NexellStartAction(Action):
     """
-    This action calls lxc-stop to stop the container.
+    This action calls lxc-start to get into the system.
     """
 
     def __init__(self):
-        super(LxcStopAction, self).__init__()
-        self.name = "lxc-stop"
-        self.summary = "stop lxc"
-        self.description = "stop the lxc container"
+        super(NexellStartAction, self).__init__()
+        self.name = "boot-nexell-device"
+        self.summary = "attempt to boot"
+        self.description = "boot into nexell device"
+        self.command = ''
 
     def validate(self):
-        super(LxcStopAction, self).validate()
-        self.errors = infrastructure_error('lxc-stop')
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcStopAction, self).run(connection, max_end_time, args)
-        lxc_name = self.get_namespace_data(action='lxc-create-action',
-                                           label='lxc', key='name')
-        lxc_cmd = ['lxc-stop', '-k', '-n', lxc_name]
-        command_output = self.run_command(lxc_cmd)
-        if command_output and command_output is not '':
-            raise JobError("Unable to stop lxc container: %s" %
-                           command_output)  # FIXME: JobError needs a unit test
+        super(NexellStartAction, self).validate()
+
+    def run(self, connection, args=None):
+        connection = super(NexellStartAction, self).run(connection, args)
+        nexell_cmd = ['hostname']
+        command_output = self.run_command(nexell_cmd)
         return connection
diff --git a/lava_dispatcher/pipeline/actions/deploy/apply_overlay.py b/lava_dispatcher/pipeline/actions/deploy/apply_overlay.py
index e155aa2..b8a6f0c 100644
--- a/lava_dispatcher/pipeline/actions/deploy/apply_overlay.py
+++ b/lava_dispatcher/pipeline/actions/deploy/apply_overlay.py
@@ -23,16 +23,17 @@ import shutil
 import subprocess
 from lava_dispatcher.pipeline.action import (
     Action,
-    InfrastructureError,
-    JobError,
-    LAVABug,
     Pipeline,
+    InfrastructureError,
+    JobError
 )
 from lava_dispatcher.pipeline.actions.deploy.overlay import OverlayAction
+# Nexell extension
 from lava_dispatcher.pipeline.utils.constants import (
     LXC_PATH,
+    NEXELL_PATH,
     RAMDISK_FNAME,
-    UBOOT_DEFAULT_HEADER_LENGTH,
+    DISPATCHER_DOWNLOAD_DIR,
 )
 from lava_dispatcher.pipeline.utils.installers import (
     add_late_command,
@@ -41,8 +42,7 @@ from lava_dispatcher.pipeline.utils.installers import (
 from lava_dispatcher.pipeline.utils.filesystem import (
     mkdtemp,
     prepare_guestfs,
-    copy_in_overlay,
-    copy_overlay_to_sparse_fs,
+    copy_in_overlay
 )
 from lava_dispatcher.pipeline.utils.shell import infrastructure_error
 from lava_dispatcher.pipeline.utils.compression import (
@@ -52,9 +52,6 @@ from lava_dispatcher.pipeline.utils.compression import (
 )
 from lava_dispatcher.pipeline.utils.strings import substitute
 from lava_dispatcher.pipeline.utils.network import dispatcher_ip
-from lava_dispatcher.pipeline.actions.deploy.prepare import PrepareKernelAction
-
-# pylint: disable=superfluous-parens,too-many-statements
 
 
 class ApplyOverlayGuest(Action):
@@ -68,26 +65,22 @@ class ApplyOverlayGuest(Action):
 
     def validate(self):
         super(ApplyOverlayGuest, self).validate()
-        self.set_namespace_data(action=self.name, label='guest', key='name', value=self.guest_filename)
-        lava_test_results_base = self.parameters['deployment_data']['lava_test_results_dir']
-        lava_test_results_dir = lava_test_results_base % self.job.job_id
-        self.set_namespace_data(action='test', label='results', key='lava_test_results_dir', value=lava_test_results_dir)
+        self.set_common_data('guest', 'name', self.guest_filename)
+        lava_test_results_dir = self.parameters['deployment_data']['lava_test_results_dir']
+        self.data['lava_test_results_dir'] = lava_test_results_dir % self.job.job_id
         if 'guest' not in self.job.device['actions']['deploy']['methods']['image']['parameters']:
             self.errors = "Device configuration does not specify size of guest filesystem."
 
-    def run(self, connection, max_end_time, args=None):
-        overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-        if not overlay_file:
-            raise LAVABug("Unable to find the overlay")
-        self.logger.debug("Overlay: %s", overlay_file)
-        guest_dir = self.mkdtemp()
+    def run(self, connection, args=None):
+        if not self.data['compress-overlay'].get('output'):
+            raise RuntimeError("Unable to find the overlay")
+        guest_dir = mkdtemp()
         guest_file = os.path.join(guest_dir, self.guest_filename)
-        self.set_namespace_data(action=self.name, label='guest', key='filename', value=guest_file)
+        self.set_common_data('guest', 'filename', guest_file)
         blkid = prepare_guestfs(
-            guest_file, overlay_file,
+            guest_file, self.data['compress-overlay'].get('output'),
             self.job.device['actions']['deploy']['methods']['image']['parameters']['guest']['size'])
         self.results = {'success': blkid}
-        self.set_namespace_data(action=self.name, label='guest', key='UUID', value=blkid)
         return connection
 
 
@@ -96,49 +89,21 @@ class ApplyOverlayImage(Action):
     def __init__(self):
         super(ApplyOverlayImage, self).__init__()
         self.name = "apply-overlay-image"
-        self.summary = "apply overlay to test image"
-        self.description = "apply overlay via guestfs to the test image"
-
-    def run(self, connection, max_end_time, args=None):
-        overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-        if overlay_file:
-            self.logger.debug("Overlay: %s", overlay_file)
-            decompressed_image = self.get_namespace_data(action='download_action', label='image', key='file')
-            self.logger.debug("Image: %s", decompressed_image)
-            root_partition = self.parameters['image']['root_partition']
-            self.logger.debug("root_partition: %s", root_partition)
-            copy_in_overlay(decompressed_image, root_partition, overlay_file)
-        else:
-            self.logger.debug("No overlay to deploy")
-        return connection
-
-
-class ApplyOverlaySparseRootfs(Action):
-
-    def __init__(self):
-        super(ApplyOverlaySparseRootfs, self).__init__()
-        self.name = "apply-overlay-sparse-rootfs"
-        self.summary = "apply overlay to sparse rootfs image"
-        self.description = "apply overlay to sparse rootfs image"
+        self.summary = "apply overlay via guestfs to test image"
 
     def validate(self):
-        super(ApplyOverlaySparseRootfs, self).validate()
-        self.errors = infrastructure_error('/usr/bin/simg2img')
-        self.errors = infrastructure_error('/bin/mount')
-        self.errors = infrastructure_error('/bin/umount')
-        self.errors = infrastructure_error('/usr/bin/img2simg')
-
-    def run(self, connection, max_end_time, args=None):
-        overlay_file = self.get_namespace_data(action='compress-overlay',
-                                               label='output', key='file')
-        if overlay_file:
-            self.logger.debug("Overlay: %s", overlay_file)
-            decompressed_image = self.get_namespace_data(
-                action='download_action', label='rootfs', key='file')
-            self.logger.debug("Image: %s", decompressed_image)
-            copy_overlay_to_sparse_fs(decompressed_image, overlay_file)
-        else:
-            self.logger.debug("No overlay to deploy")
+        super(ApplyOverlayImage, self).validate()
+
+    def run(self, connection, args=None):
+        if not self.data['compress-overlay'].get('output'):
+            raise RuntimeError("Unable to find the overlay")
+        overlay = self.data['compress-overlay'].get('output')
+        self.logger.debug("Overlay: %s", overlay)
+        decompressed_image = self.data['download_action']['image']['file']
+        self.logger.debug("Image: %s", decompressed_image)
+        root_partition = self.parameters['image']['root_partition']
+        self.logger.debug("root_partition: %s", root_partition)
+        copy_in_overlay(decompressed_image, root_partition, overlay)
         return connection
 
 
@@ -159,18 +124,12 @@ class PrepareOverlayTftp(Action):
         self.internal_pipeline.add_action(ExtractRamdisk())  # idempotent, checks for a ramdisk parameter
         self.internal_pipeline.add_action(ExtractModules())  # idempotent, checks for a modules parameter
         self.internal_pipeline.add_action(ApplyOverlayTftp())
-        if 'kernel' in parameters and 'type' in parameters['kernel']:
-            self.internal_pipeline.add_action(PrepareKernelAction())
         self.internal_pipeline.add_action(ConfigurePreseedFile())  # idempotent, checks for a preseed parameter
         self.internal_pipeline.add_action(CompressRamdisk())  # idempotent, checks for a ramdisk parameter
 
-    def run(self, connection, max_end_time, args=None):
-        connection = super(PrepareOverlayTftp, self).run(connection, max_end_time, args)
-        ramdisk = self.get_namespace_data(
-            action='download_action',
-            label='file',
-            key='ramdisk'
-        )
+    def run(self, connection, args=None):
+        connection = super(PrepareOverlayTftp, self).run(connection, args)
+        ramdisk = self.get_common_data('file', 'ramdisk')
         if ramdisk:  # nothing else to do
             return connection
         return connection
@@ -190,60 +149,32 @@ class ApplyOverlayTftp(Action):
         self.summary = "apply lava overlay test files"
         self.description = "unpack the overlay into the nfsrootfs or ramdisk"
 
-    def validate(self):
-        super(ApplyOverlayTftp, self).validate()
-        persist = self.parameters.get('persistent_nfs', None)
-        if persist:
-            if not isinstance(persist, dict):
-                self.errors = "Invalid persistent_nfs parameter."
-            if 'address' not in persist:
-                self.errors = "Missing address for persistent NFS"
-
-    def run(self, connection, max_end_time, args=None):  # pylint: disable=too-many-branches
-        connection = super(ApplyOverlayTftp, self).run(connection, max_end_time, args)
-        directory = None
-        nfs_address = None
+    def run(self, connection, args=None):
+        connection = super(ApplyOverlayTftp, self).run(connection, args)
         overlay_file = None
+        directory = None
+        nfs_url = None
         if self.parameters.get('nfsrootfs', None) is not None:
-            if not self.parameters['nfsrootfs'].get('install_overlay', True):
-                self.logger.info("Skipping applying overlay to NFS")
-                return connection
-            overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-            directory = self.get_namespace_data(action='extract-rootfs', label='file', key='nfsroot')
+            overlay_file = self.data['compress-overlay'].get('output')
+            directory = self.get_common_data('file', 'nfsroot')
             self.logger.info("Applying overlay to NFS")
-        elif self.parameters.get('images', {}).get('nfsrootfs', None) is not None:
-            if not self.parameters['images']['nfsrootfs'].get('install_overlay', True):
-                self.logger.info("Skipping applying overlay to NFS")
-                return connection
-            overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-            directory = self.get_namespace_data(action='extract-rootfs', label='file', key='nfsroot')
-            self.logger.info("Applying overlay to NFS")
-        elif self.parameters.get('persistent_nfs', None) is not None:
-            if not self.parameters['persistent_nfs'].get('install_overlay', True):
-                self.logger.info("Skipping applying overlay to persistent NFS")
-                return connection
-            overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-            nfs_address = self.parameters['persistent_nfs'].get('address')
-            self.logger.info("Applying overlay to persistent NFS address %s", nfs_address)
+        elif self.parameters.get('nfs_url', None) is not None:
+            nfs_url = self.parameters.get('nfs_url')
+            overlay_file = self.data['compress-overlay'].get('output')
+            self.logger.info("Applying overlay to persistent NFS")
             # need to mount the persistent NFS here.
-            # We can't use self.mkdtemp() here because this directory should
-            # not be removed if umount fails.
             directory = mkdtemp(autoremove=False)
             try:
-                subprocess.check_output(['mount', '-t', 'nfs', nfs_address, directory])
+                subprocess.check_output(['mount', '-t', 'nfs', nfs_url, directory])
             except subprocess.CalledProcessError as exc:
                 raise JobError(exc)
         elif self.parameters.get('ramdisk', None) is not None:
-            if not self.parameters['ramdisk'].get('install_overlay', True):
-                self.logger.info("Skipping applying overlay to ramdisk")
-                return connection
-            overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-            directory = self.get_namespace_data(action='extract-overlay-ramdisk', label='extracted_ramdisk', key='directory')
-            if overlay_file:
-                self.logger.info("Applying overlay %s to ramdisk", overlay_file)
+            overlay_file = self.data['compress-overlay'].get('output')
+            directory = self.data['extract-overlay-ramdisk']['extracted_ramdisk']
+            self.logger.info("Applying overlay to ramdisk")
         elif self.parameters.get('rootfs', None) is not None:
-            overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
-            directory = self.get_namespace_data(action='apply-overlay', label='file', key='root')
+            overlay_file = self.data['compress-overlay'].get('output')
+            directory = self.get_common_data('file', 'root')
         else:
             self.logger.debug("No overlay directory")
             self.logger.debug(self.parameters)
@@ -251,16 +182,17 @@ class ApplyOverlayTftp(Action):
             # centos installer ramdisk doesnt like having anything other
             # than the kickstart config being inserted. Instead, make the
             # overlay accessible through tftp. Yuck.
-            tftp_dir = os.path.dirname(self.get_namespace_data(action='download_action', label='ramdisk', key='file'))
+            tftp_dir = os.path.dirname(self.data['download_action']['ramdisk']['file'])
             shutil.copy(overlay_file, tftp_dir)
-            suffix = self.get_namespace_data(action='tftp-deploy', label='tftp', key='suffix')
-            if not suffix:
-                suffix = ''
-            self.set_namespace_data(action=self.name, label='file', key='overlay',
-                                    value=os.path.join(suffix, "ramdisk", os.path.basename(overlay_file)))
+            suffix = self.data['tftp-deploy'].get('suffix', '')
+            self.set_common_data('file', 'overlay', os.path.join(suffix, os.path.basename(overlay_file)))
+        untar_file(overlay_file, directory)
+        if nfs_url:
+            subprocess.check_output(['umount', directory])
+            os.rmdir(directory)  # fails if the umount fails
         if overlay_file:
             untar_file(overlay_file, directory)
-            if nfs_address:
+            if nfs_url:
                 subprocess.check_output(['umount', directory])
                 os.rmdir(directory)  # fails if the umount fails
         return connection
@@ -281,14 +213,19 @@ class ExtractRootfs(Action):  # pylint: disable=too-many-instance-attributes
         self.use_tarfile = True
         self.use_lzma = False
 
-    def run(self, connection, max_end_time, args=None):
+    def validate(self):
+        super(ExtractRootfs, self).validate()
+        if not self.parameters.get(self.param_key, None):  # idempotency
+            return
+
+    def run(self, connection, args=None):
         if not self.parameters.get(self.param_key, None):  # idempotency
             return connection
-        connection = super(ExtractRootfs, self).run(connection, max_end_time, args)
-        root = self.get_namespace_data(action='download_action', label=self.param_key, key='file')
-        root_dir = self.mkdtemp()
+        connection = super(ExtractRootfs, self).run(connection, args)
+        root = self.data['download_action'][self.param_key]['file']
+        root_dir = mkdtemp(basedir=DISPATCHER_DOWNLOAD_DIR)
         untar_file(root, root_dir)
-        self.set_namespace_data(action='extract-rootfs', label='file', key=self.file_key, value=root_dir)
+        self.set_common_data('file', self.file_key, root_dir)
         self.logger.debug("Extracted %s to %s", self.file_key, root_dir)
         return connection
 
@@ -304,13 +241,15 @@ class ExtractNfsRootfs(ExtractRootfs):
         self.summary = "unpack nfsrootfs, ready to apply lava overlay"
         self.param_key = 'nfsrootfs'
         self.file_key = "nfsroot"
+        self.rootdir = DISPATCHER_DOWNLOAD_DIR
 
     def validate(self):
         super(ExtractNfsRootfs, self).validate()
         if not self.parameters.get(self.param_key, None):  # idempotency
             return
-        if not self.get_namespace_data(
-                action='download_action', label=self.param_key, key='file'):
+        if 'download_action' not in self.data:
+            self.errors = "missing download_action in parameters"
+        elif 'file' not in self.data['download_action'][self.param_key]:
             self.errors = "no file specified extract as %s" % self.param_key
         if not os.path.exists('/usr/sbin/exportfs'):
             raise InfrastructureError("NFS job requested but nfs-kernel-server not installed.")
@@ -321,26 +260,23 @@ class ExtractNfsRootfs(ExtractRootfs):
             if not prefix.endswith('/'):
                 self.errors = 'prefix must be a directory and end with /'
 
-    def run(self, connection, max_end_time, args=None):
+    def run(self, connection, args=None):
         if not self.parameters.get(self.param_key, None):  # idempotency
             return connection
-        connection = super(ExtractNfsRootfs, self).run(connection, max_end_time, args)
-
+        connection = super(ExtractNfsRootfs, self).run(connection, args)
+        root = self.data['download_action'][self.param_key]['file']
+        root_dir = mkdtemp(basedir=DISPATCHER_DOWNLOAD_DIR)
+        untar_file(root, root_dir)
         if 'prefix' in self.parameters[self.param_key]:
             prefix = self.parameters[self.param_key]['prefix']
-            self.logger.warning("Adding '%s' prefix, any other content will not be visible.",
-                                prefix)
-
-            # Grab the path already defined in super().run() and add the prefix
-            root_dir = self.get_namespace_data(
-                action='extract-rootfs',
-                label='file',
-                key=self.file_key
-            )
-            root_dir = os.path.join(root_dir, prefix)
-            # sets the directory into which the overlay is unpacked and which
-            # is used in the substitutions into the bootloader command string.
-            self.set_namespace_data(action='extract-rootfs', label='file', key=self.file_key, value=root_dir)
+            self.logger.warning("Adding '%s' prefix, any other content will not be visible." % prefix)
+            self.rootdir = os.path.join(root_dir, prefix)
+        else:
+            self.rootdir = root_dir
+        # sets the directory into which the overlay is unpacked and
+        # which is used in the substitutions into the bootloader command string.
+        self.set_common_data('file', self.file_key, self.rootdir)
+        self.logger.debug("Extracted %s to %s", self.file_key, self.rootdir)
         return connection
 
 
@@ -355,11 +291,16 @@ class ExtractModules(Action):
         self.summary = "extract kernel modules"
         self.description = "extract supplied kernel modules"
 
-    def run(self, connection, max_end_time, args=None):
+    def validate(self):
+        super(ExtractModules, self).validate()
+        if not self.parameters.get('modules', None):  # idempotency
+            return
+
+    def run(self, connection, args=None):
         if not self.parameters.get('modules', None):  # idempotency
             return connection
-        connection = super(ExtractModules, self).run(connection, max_end_time, args)
-        modules = self.get_namespace_data(action='download_action', label='modules', key='file')
+        connection = super(ExtractModules, self).run(connection, args)
+        modules = self.data['download_action']['modules']['file']
         if not self.parameters.get('ramdisk', None):
             if not self.parameters.get('nfsrootfs', None):
                 raise JobError("Unable to identify a location for the unpacked modules")
@@ -367,28 +308,17 @@ class ExtractModules(Action):
         # as the kernel may need some modules to raise the network and
         # will need other modules to support operations within the NFS
         if self.parameters.get('nfsrootfs', None):
-            if not self.parameters['nfsrootfs'].get('install_modules', True):
-                self.logger.info("Skipping applying overlay to NFS")
-                return connection
-            root = self.get_namespace_data(
-                action='extract-rootfs',
-                label='file',
-                key='nfsroot'
-            )
+            root = self.get_common_data('file', 'nfsroot')
             self.logger.info("extracting modules file %s to %s", modules, root)
             untar_file(modules, root)
         if self.parameters.get('ramdisk', None):
-            if not self.parameters['ramdisk'].get('install_modules', True):
-                self.logger.info("Not adding modules to the ramdisk.")
-                return
-            root = self.get_namespace_data(
-                action='extract-overlay-ramdisk', label='extracted_ramdisk', key='directory')
+            root = self.data['extract-overlay-ramdisk']['extracted_ramdisk']
             self.logger.info("extracting modules file %s to %s", modules, root)
             untar_file(modules, root)
         try:
             os.unlink(modules)
         except OSError as exc:
-            raise InfrastructureError("Unable to remove tarball: '%s' - %s" % (modules, exc))
+            raise RuntimeError("Unable to remove tarball: '%s' - %s" % (modules, exc))
         return connection
 
 
@@ -405,57 +335,46 @@ class ExtractRamdisk(Action):
         self.name = "extract-overlay-ramdisk"
         self.summary = "extract the ramdisk"
         self.description = "extract ramdisk to a temporary directory"
-        self.skip = False
 
     def validate(self):
         super(ExtractRamdisk, self).validate()
         if not self.parameters.get('ramdisk', None):  # idempotency
             return
-        if not self.parameters['ramdisk'].get('install_modules', True) and \
-                not self.parameters['ramdisk'].get('install_overlay', True):
-            self.skip = True
-            return
 
-    def run(self, connection, max_end_time, args=None):
+    def run(self, connection, args=None):
         if not self.parameters.get('ramdisk', None):  # idempotency
             return connection
-        ramdisk = self.get_namespace_data(action='download_action', label='ramdisk', key='file')
-        if self.skip:
-            self.logger.info("Not extracting ramdisk.")
-            suffix = self.get_namespace_data(action='tftp-deploy', label='tftp', key='suffix')
-            filename = os.path.join(suffix, "ramdisk", os.path.basename(ramdisk))
-            # declare the original ramdisk as the name to be used later.
-            self.set_namespace_data(action='compress-ramdisk', label='file', key='ramdisk', value=filename)
-            return
-        connection = super(ExtractRamdisk, self).run(connection, max_end_time, args)
-        ramdisk_dir = self.mkdtemp()
+        connection = super(ExtractRamdisk, self).run(connection, args)
+        ramdisk = self.data['download_action']['ramdisk']['file']
+        ramdisk_dir = mkdtemp()
         extracted_ramdisk = os.path.join(ramdisk_dir, 'ramdisk')
-        os.mkdir(extracted_ramdisk, 0o755)
+        os.mkdir(extracted_ramdisk)
         compression = self.parameters['ramdisk'].get('compression', None)
         suffix = ""
         if compression:
             suffix = ".%s" % compression
         ramdisk_compressed_data = os.path.join(ramdisk_dir, RAMDISK_FNAME + suffix)
         if self.parameters['ramdisk'].get('header', None) == 'u-boot':
-            cmd = ('dd if=%s of=%s ibs=%s skip=1' % (
-                ramdisk, ramdisk_compressed_data, UBOOT_DEFAULT_HEADER_LENGTH)).split(' ')
+            # TODO: 64 bytes is empirical - may need to be configurable in the future
+            cmd = ('dd if=%s of=%s ibs=64 skip=1' % (ramdisk, ramdisk_compressed_data)).split(' ')
             try:
                 self.run_command(cmd)
             except:
-                raise LAVABug('Unable to remove uboot header: %s' % ramdisk)
+                raise RuntimeError('Unable to remove uboot header: %s' % ramdisk)
         else:
             # give the file a predictable name
             shutil.move(ramdisk, ramdisk_compressed_data)
+        self.logger.debug(os.system("file %s" % ramdisk_compressed_data))
         ramdisk_data = decompress_file(ramdisk_compressed_data, compression)
         pwd = os.getcwd()
         os.chdir(extracted_ramdisk)
-        cmd = ('cpio -iud -F %s' % ramdisk_data).split(' ')
+        cmd = ('cpio -i -F %s' % ramdisk_data).split(' ')
         if not self.run_command(cmd):
-            raise JobError('Unable to extract cpio archive: %s - missing header definition (i.e. u-boot)?' % ramdisk_data)
+            raise JobError('Unable to uncompress: %s - missing ramdisk-type?' % ramdisk_data)
         os.chdir(pwd)
         # tell other actions where the unpacked ramdisk can be found
-        self.set_namespace_data(action=self.name, label='extracted_ramdisk', key='directory', value=extracted_ramdisk)
-        self.set_namespace_data(action=self.name, label='ramdisk_file', key='file', value=ramdisk_data)
+        self.data[self.name]['extracted_ramdisk'] = extracted_ramdisk  # directory
+        self.data[self.name]['ramdisk_file'] = ramdisk_data  # filename
         return connection
 
 
@@ -470,16 +389,11 @@ class CompressRamdisk(Action):
         self.description = "recreate a ramdisk with the overlay applied."
         self.mkimage_arch = None
         self.add_header = None
-        self.skip = False
 
     def validate(self):
         super(CompressRamdisk, self).validate()
         if not self.parameters.get('ramdisk', None):  # idempotency
             return
-        if not self.parameters['ramdisk'].get('install_modules', True) and \
-                not self.parameters['ramdisk'].get('install_overlay', True):
-            self.skip = True
-            return
         if 'parameters' in self.job.device['actions']['deploy']:
             self.add_header = self.job.device['actions']['deploy']['parameters'].get('add_header', None)
             if self.add_header is not None:
@@ -492,20 +406,16 @@ class CompressRamdisk(Action):
                 else:
                     self.errors = "ramdisk: add_header: unknown header type"
 
-    def run(self, connection, max_end_time, args=None):  # pylint: disable=too-many-locals
+    def run(self, connection, args=None):
         if not self.parameters.get('ramdisk', None):  # idempotency
             return connection
-        if self.skip:
-            return connection
-        connection = super(CompressRamdisk, self).run(connection, max_end_time, args)
-        ramdisk_dir = self.get_namespace_data(
-            action='extract-overlay-ramdisk', label='extracted_ramdisk', key='directory')
-        ramdisk_data = self.get_namespace_data(
-            action='extract-overlay-ramdisk', label='ramdisk_file', key='file')
-        if not ramdisk_dir:
-            raise LAVABug("Unable to find unpacked ramdisk")
-        if not ramdisk_data:
-            raise LAVABug("Unable to find ramdisk directory")
+        connection = super(CompressRamdisk, self).run(connection, args)
+        if 'extracted_ramdisk' not in self.data['extract-overlay-ramdisk']:
+            raise RuntimeError("Unable to find unpacked ramdisk")
+        if 'ramdisk_file' not in self.data['extract-overlay-ramdisk']:
+            raise RuntimeError("Unable to find ramdisk directory")
+        ramdisk_dir = self.data['extract-overlay-ramdisk']['extracted_ramdisk']
+        ramdisk_data = self.data['extract-overlay-ramdisk']['ramdisk_file']
         if self.parameters.get('preseed', None):
             if self.parameters["deployment_data"].get("preseed_to_ramdisk", None):
                 # download action must have completed to get this far
@@ -514,20 +424,18 @@ class CompressRamdisk(Action):
                 # from deployment_data which we can use in the boot commands.
                 filename = self.parameters["deployment_data"]["preseed_to_ramdisk"]
                 self.logger.info("Copying preseed file into ramdisk: %s", filename)
-                shutil.copy(self.get_namespace_data(
-                    action='download_action', label='preseed',
-                    key='file'), os.path.join(ramdisk_dir, filename))
-                self.set_namespace_data(action=self.name, label='file', key='preseed_local', value=filename)
+                shutil.copy(self.data['download_action']['preseed']['file'], os.path.join(ramdisk_dir, filename))
+                self.set_common_data('file', 'preseed_local', filename)
         pwd = os.getcwd()
         os.chdir(ramdisk_dir)
-        self.logger.info("Building ramdisk %s containing %s",
-                         ramdisk_data, ramdisk_dir)
+        self.logger.debug("Building ramdisk %s containing %s",
+                          ramdisk_data, ramdisk_dir)
         cmd = "find . | cpio --create --format='newc' > %s" % ramdisk_data
         try:
             # safe to use shell=True here, no external arguments
-            log = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
+            log = subprocess.check_output(cmd, shell=True)
         except OSError as exc:
-            raise InfrastructureError('Unable to create cpio filesystem: %s' % exc)
+            raise RuntimeError('Unable to create cpio filesystem: %s' % exc)
         # lazy-logging would mean that the quoting of cmd causes invalid YAML
         self.logger.debug("%s\n%s" % (cmd, log))  # pylint: disable=logging-not-lazy
 
@@ -535,31 +443,24 @@ class CompressRamdisk(Action):
         compression = self.parameters['ramdisk'].get('compression', None)
         final_file = compress_file(ramdisk_data, compression)
         os.chdir(pwd)
-        tftp_dir = os.path.dirname(self.get_namespace_data(
-            action='download_action', label='ramdisk', key='file'))
+        tftp_dir = os.path.dirname(self.data['download_action']['ramdisk']['file'])
 
         if self.add_header == 'u-boot':
             ramdisk_uboot = final_file + ".uboot"
             self.logger.debug("Adding RAMdisk u-boot header.")
             cmd = ("mkimage -A %s -T ramdisk -C none -d %s %s" % (self.mkimage_arch, final_file, ramdisk_uboot)).split(' ')
             if not self.run_command(cmd):
-                raise InfrastructureError("Unable to add uboot header to ramdisk")
+                raise RuntimeError("Unable to add uboot header to ramdisk")
             final_file = ramdisk_uboot
 
         shutil.move(final_file, os.path.join(tftp_dir, os.path.basename(final_file)))
         self.logger.debug("rename %s to %s",
                           final_file, os.path.join(tftp_dir, os.path.basename(final_file)))
         if self.parameters['to'] == 'tftp':
-            suffix = self.get_namespace_data(action='tftp-deploy', label='tftp', key='suffix')
-            if not suffix:
-                suffix = ''
-            self.set_namespace_data(
-                action=self.name,
-                label='file', key='ramdisk', value=os.path.join(suffix, "ramdisk", os.path.basename(final_file)))
+            suffix = self.data['tftp-deploy'].get('suffix', '')
+            self.set_common_data('file', 'ramdisk', os.path.join(suffix, os.path.basename(final_file)))
         else:
-            self.set_namespace_data(
-                action=self.name,
-                label='file', key='ramdisk', value=final_file)
+            self.set_common_data('file', 'ramdisk', final_file)
         return connection
 
 
@@ -578,24 +479,22 @@ class ApplyLxcOverlay(Action):
         super(ApplyLxcOverlay, self).validate()
         self.errors = infrastructure_error('tar')
 
-    def run(self, connection, max_end_time, args=None):
-        connection = super(ApplyLxcOverlay, self).run(connection, max_end_time, args)
-        overlay_file = self.get_namespace_data(action='compress-overlay', label='output', key='file')
+    def run(self, connection, args=None):
+        connection = super(ApplyLxcOverlay, self).run(connection, args)
+        overlay_file = self.data['compress-overlay'].get('output')
         if overlay_file is None:
             self.logger.debug("skipped %s", self.name)
             return connection
-        lxc_name = self.get_namespace_data(
-            action='lxc-create-action',
-            label='lxc', key='name')
-        lxc_path = os.path.join(LXC_PATH, lxc_name, 'rootfs')
+        lxc_path = os.path.join(LXC_PATH, self.get_common_data('lxc', 'name'),
+                                "rootfs")
         if not os.path.exists(lxc_path):
-            raise LAVABug("Lxc container rootfs not found")
+            raise JobError("Lxc container rootfs not found")
         tar_cmd = ['tar', '--warning', 'no-timestamp', '-C', lxc_path, '-xaf',
                    overlay_file]
         command_output = self.run_command(tar_cmd)
         if command_output and command_output is not '':
             raise JobError("Unable to untar overlay: %s" %
-                           command_output)
+                           command_output)  # FIXME: JobError needs a unit test
 
         # FIXME: Avoid copying this special 'lava-test-runner' which does not
         #        have 'sync' in cleanup. This should be handled during the
@@ -607,10 +506,68 @@ class ApplyLxcOverlay(Action):
         try:
             shutil.copy(fname, output_file)
         except IOError:
-            raise InfrastructureError("Unable to copy: %s" % output_file)
+            raise JobError("Unable to copy: %s" % output_file)
 
         return connection
 
+# Nexell extension
+class ApplyNexellOverlay(Action):
+
+    def __init__(self):
+        super(ApplyNexellOverlay, self).__init__()
+        self.name = "apply-nexell-overlay"
+        self.summary = "apply overlay on the container"
+        self.description = "apply the overlay to the container by copying"
+        self.lava_test_dir = os.path.realpath(
+            '%s/../../../pipeline/lava_test_shell' % os.path.dirname(__file__))
+        self.scripts_to_copy = ['lava-test-runner']
+
+    def validate(self):
+        super(ApplyNexellOverlay, self).validate()
+        self.errors = infrastructure_error('tar')
+
+    def run(self, connection, args=None):
+        connection = super(ApplyNexellOverlay, self).run(connection, args)
+        overlay_file = self.data['compress-overlay'].get('output')
+        adb_serial_number = self.job.device['adb_serial_number']
+        self.logger.debug("SUKER: deploy/apply_overlay.py: "+str(adb_serial_number))
+        if overlay_file is None:
+            self.logger.debug("skipped %s", self.name)
+            return connection
+        nexell_path = os.path.join(NEXELL_PATH)
+        if not os.path.exists(nexell_path):
+            raise JobError("Nexell path not found")
+        tar_cmd = ['tar', '--warning', 'no-timestamp', '-C', nexell_path, '-xaf',
+                   overlay_file]
+        command_output = self.run_command(tar_cmd)
+        if command_output and command_output is not '':
+            raise JobError("Unable to untar overlay: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+
+        # FIXME: Avoid copying this special 'lava-test-runner' which does not
+        #        have 'sync' in cleanup. This should be handled during the
+        #        creation of the overlay instead. Make a special case to copy
+        #        lxc specific scripts, with distro specific versions.
+        fname = os.path.join(self.lava_test_dir, 'lava-test-runner')
+        output_file = '%s/bin/%s' % (nexell_path, os.path.basename(fname))
+
+        self.logger.debug("SUKER: deploy/apply_overlay.py output_file: "+str(output_file))
+        self.logger.debug("SUKER: deploy/apply_overlay.py nexell_path: "+str(nexell_path))
+        
+        lava_test_results_dir = self.data['lava_test_results_dir']
+        self.logger.debug("SUKER: deploy/apply_overlay.py var/lib/nexell path: "+str(lava_test_results_dir))
+
+        # adb push
+        nexell_real_path = nexell_path + lava_test_results_dir
+        adb_cmd = ['/opt/android-sdk-linux/platform-tools/adb', '-s', adb_serial_number, 'push', nexell_real_path, '/']
+        self.logger.debug("SUKER: apply_overlay.py: " + str(adb_cmd))        
+        command_output = self.run_command(adb_cmd)
+
+        adb_cmd = ['/opt/android-sdk-linux/platform-tools/adb', '-s', adb_serial_number, 'push', fname, lava_test_results_dir+'/bin/']
+        self.logger.debug("SUKER: apply_overlay.py: " + str(adb_cmd))
+        command_output = self.run_command(adb_cmd)
+        return connection
+
 
 class ConfigurePreseedFile(Action):
     def __init__(self):
@@ -619,20 +576,17 @@ class ConfigurePreseedFile(Action):
         self.summary = "add commands to installer config"
         self.description = "add commands to automated installers, to copy the lava test overlay to the installed system"
 
-    def run(self, connection, max_end_time, args=None):
-        if 'deployment_data' not in self.parameters:
-            return connection
+    def validate(self):
+        super(ConfigurePreseedFile, self).validate()
+        if not self.parameters.get('preseed', None):
+            return
+
+    def run(self, connection, args=None):
         if self.parameters["deployment_data"].get('installer_extra_cmd', None):
             if self.parameters.get('os', None) == "debian_installer":
-                add_late_command(self.get_namespace_data(action='download_action', label='preseed', key='file'),
-                                 self.parameters["deployment_data"]["installer_extra_cmd"])
+                add_late_command(self.data['download_action']['preseed']['file'], self.parameters["deployment_data"]["installer_extra_cmd"])
             if self.parameters.get('os', None) == "centos_installer":
-                ip_addr = dispatcher_ip(self.job.parameters['dispatcher'])
-                overlay = self.get_namespace_data(
-                    action='download_action', label='file', key='overlay')
-                substitutions = {
-                    '{OVERLAY_URL}': 'tftp://' + ip_addr + '/' + overlay
-                }
+                substitutions = {}
+                substitutions['{OVERLAY_URL}'] = 'tftp://' + dispatcher_ip() + '/' + self.get_common_data('file', 'overlay')
                 post_command = substitute([self.parameters["deployment_data"]["installer_extra_cmd"]], substitutions)
-                add_to_kickstart(self.get_namespace_data(action='download_action', label='preseed', key='file'), post_command[0])
-        return connection
+                add_to_kickstart(self.data['download_action']['preseed']['file'], post_command[0])
diff --git a/lava_dispatcher/pipeline/actions/deploy/fastboot.py b/lava_dispatcher/pipeline/actions/deploy/fastboot.py
index 5c05485..c3f0cd4 100644
--- a/lava_dispatcher/pipeline/actions/deploy/fastboot.py
+++ b/lava_dispatcher/pipeline/actions/deploy/fastboot.py
@@ -20,32 +20,22 @@
 
 from lava_dispatcher.pipeline.logical import Deployment
 from lava_dispatcher.pipeline.connections.serial import ConnectDevice
-from lava_dispatcher.pipeline.power import (
-    PowerOn,
-)
+from lava_dispatcher.pipeline.power import ResetDevice
 from lava_dispatcher.pipeline.action import (
-    ConfigurationError,
-    InfrastructureError,
     Pipeline,
+    JobError,
 )
 from lava_dispatcher.pipeline.actions.deploy import DeployAction
 from lava_dispatcher.pipeline.actions.deploy.lxc import LxcAddDeviceAction
-from lava_dispatcher.pipeline.actions.deploy.apply_overlay import ApplyOverlaySparseRootfs
-from lava_dispatcher.pipeline.actions.deploy.environment import DeployDeviceEnvironment
-from lava_dispatcher.pipeline.actions.deploy.overlay import (
-    CustomisationAction,
-    OverlayAction,
-)
+from lava_dispatcher.pipeline.actions.deploy.overlay import OverlayAction
 from lava_dispatcher.pipeline.actions.deploy.download import (
     DownloaderAction,
 )
-from lava_dispatcher.pipeline.utils.filesystem import copy_to_lxc
-from lava_dispatcher.pipeline.protocols.lxc import LxcProtocol
-from lava_dispatcher.pipeline.actions.boot import WaitUSBDeviceAction
-from lava_dispatcher.pipeline.actions.boot.u_boot import UBootEnterFastbootAction
-
-
-# pylint: disable=too-many-return-statements
+from lava_dispatcher.pipeline.utils.filesystem import mkdtemp, copy_to_lxc
+from lava_dispatcher.pipeline.utils.constants import (
+    DISPATCHER_DOWNLOAD_DIR,
+    FASTBOOT_REBOOT_TIMEOUT,
+)
 
 
 def fastboot_accept(device, parameters):
@@ -61,17 +51,15 @@ def fastboot_accept(device, parameters):
     if not device:
         return False
     if 'actions' not in device:
-        raise ConfigurationError("Invalid device configuration")
+        raise RuntimeError("Invalid device configuration")
     if 'deploy' not in device['actions']:
         return False
     if 'adb_serial_number' not in device:
         return False
     if 'fastboot_serial_number' not in device:
         return False
-    if 'fastboot_options' not in device:
-        return False
     if 'methods' not in device['actions']['deploy']:
-        raise ConfigurationError("Device misconfiguration")
+        raise RuntimeError("Device misconfiguration")
     return True
 
 
@@ -105,55 +93,164 @@ class FastbootAction(DeployAction):  # pylint:disable=too-many-instance-attribut
         self.name = "fastboot-deploy"
         self.description = "download files and deploy using fastboot"
         self.summary = "fastboot deployment"
-        self.force_prompt = False
+        self.fastboot_dir = DISPATCHER_DOWNLOAD_DIR
+        try:
+            self.fastboot_dir = mkdtemp(basedir=DISPATCHER_DOWNLOAD_DIR)
+        except OSError:
+            pass
 
     def validate(self):
         super(FastbootAction, self).validate()
-        if not self.test_needs_deployment(self.parameters):
-            return
         lava_test_results_dir = self.parameters['deployment_data']['lava_test_results_dir']
         lava_test_results_dir = lava_test_results_dir % self.job.job_id
-        self.set_namespace_data(action='test', label='results', key='lava_test_results_dir', value=lava_test_results_dir)
-        lava_test_sh_cmd = self.parameters['deployment_data']['lava_test_sh_cmd']
-        self.set_namespace_data(action=self.name, label='shared', key='lava_test_sh_cmd', value=lava_test_sh_cmd)
+        self.data['lava_test_results_dir'] = lava_test_results_dir
+        namespace = self.parameters.get('namespace', None)
+        if namespace:
+            self.action_namespaces.append(namespace)
+            self.set_common_data(namespace, 'lava_test_results_dir',
+                                 lava_test_results_dir)
+            lava_test_sh_cmd = self.parameters['deployment_data']['lava_test_sh_cmd']
+            self.set_common_data(namespace, 'lava_test_sh_cmd',
+                                 lava_test_sh_cmd)
 
     def populate(self, parameters):
         self.internal_pipeline = Pipeline(parent=self, job=self.job, parameters=parameters)
-        if self.test_needs_overlay(parameters):
-            self.internal_pipeline.add_action(CustomisationAction())
-            self.internal_pipeline.add_action(OverlayAction())
-        # Check if the device has a power command such as HiKey, Dragonboard,
-        # etc. against device that doesn't like Nexus, etc.
-        if self.job.device.get('fastboot_via_uboot', False):
-            self.internal_pipeline.add_action(ConnectDevice())
-            self.internal_pipeline.add_action(UBootEnterFastbootAction())
-        elif self.job.device.power_command:
-            self.force_prompt = True
-            self.internal_pipeline.add_action(ConnectDevice())
-            self.internal_pipeline.add_action(PowerOn())
+        self.internal_pipeline.add_action(OverlayAction())
+        if hasattr(self.job.device, 'power_state'):
+            if self.job.device.power_state in ['on', 'off']:
+                self.internal_pipeline.add_action(ConnectDevice())
+                self.internal_pipeline.add_action(ResetDevice())
+
+        image_keys = list(parameters['images'].keys())
+        # Nexell extension
+        if 'nexell_ext' in image_keys:
+            self.logger.debug("SUKER: parameters in deploy/fastboot.py : " + str(parameters))
+            self.internal_pipeline.add_action(EnterNexellFastbootAction(parameters,'deploy_script','deploy_command1'))
+            self.internal_pipeline.add_action(ApplyNexellDeployAction(parameters,'deploy_script','deploy_command2','dir_name'))
         else:
             self.internal_pipeline.add_action(EnterFastbootAction())
-        self.internal_pipeline.add_action(WaitUSBDeviceAction(
-            device_actions=['add']))
+            self.internal_pipeline.add_action(LxcAddDeviceAction())
+            
+        if 'image' in image_keys:
+            download = DownloaderAction('image', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(FastbootUpdateAction())
+        if 'ptable' in image_keys:
+            download = DownloaderAction('ptable', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplyPtableAction())
+        if 'boot' in image_keys:
+            download = DownloaderAction('boot', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplyBootAction())
+        if 'cache' in image_keys:
+            download = DownloaderAction('cache', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplyCacheAction())
+        if 'userdata' in image_keys:
+            download = DownloaderAction('userdata', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplyUserdataAction())
+        if 'system' in image_keys:
+            download = DownloaderAction('system', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplySystemAction())
+        if 'vendor' in image_keys:
+            download = DownloaderAction('vendor', self.fastboot_dir)
+            download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
+            self.internal_pipeline.add_action(download)
+            self.internal_pipeline.add_action(ApplyVendorAction())
 
-        fastboot_dir = self.mkdtemp()
-        image_keys = list(parameters['images'].keys())
-        image_keys.sort()
-        for image in image_keys:
-            if image != 'yaml_line':
-                download = DownloaderAction(image, fastboot_dir)
-                download.max_retries = 3  # overridden by failure_retry in the parameters, if set.
-                self.internal_pipeline.add_action(download)
-                if image == 'rootfs':
-                    if self.test_needs_overlay(parameters):
-                        self.internal_pipeline.add_action(
-                            ApplyOverlaySparseRootfs())
-                    if self.test_needs_deployment(parameters):
-                        self.internal_pipeline.add_action(
-                            DeployDeviceEnvironment())
-
-        self.internal_pipeline.add_action(LxcAddDeviceAction())
-        self.internal_pipeline.add_action(FastbootFlashAction())
+
+
+class EnterNexellFastbootAction(DeployAction):
+    """
+    Enters fastboot bootloader.
+    """
+
+    def __init__(self,parameters, key1, key2):
+        super(EnterNexellFastbootAction, self).__init__()
+        self.name = "enter_nexell_fastboot_action"
+        self.description = "enter fastboot bootloader"
+        self.summary = "enter fastboot"
+        self.retries = 10
+        self.sleep = 10
+        self.cmd = parameters['images']['nexell_ext'][key1]
+        self.param = parameters['images']['nexell_ext'][key2]
+
+    def validate(self):
+        super(EnterNexellFastbootAction, self).validate()
+
+    def run(self, connection, args=None):
+        connection = super(EnterNexellFastbootAction, self).run(connection, args)        
+        telnet_cmd = [self.cmd, self.param]
+        self.logger.debug("SUKER: telnet_cmd " + str(telnet_cmd))
+        command_output = self.run_command(telnet_cmd)
+        self.logger.debug("SUKER: self.errors " + str(self.errors))
+        self.results = {'status': 'finished'}
+        return connection
+
+
+class ApplyNexellDeployAction(DeployAction):
+    """
+    Fastboot deploy Nexell image.
+    """
+    def __init__(self,parameters, key1, key2, key3):
+        super(ApplyNexellDeployAction, self).__init__()
+        self.name = "fastboot_apply_nexell_action1"
+        self.description = "fastboot apply nexell image"
+        self.summary = "fastboot apply nexell"
+        self.retries = 1
+        self.sleep = 3
+        self.cmd_script = parameters['images']['nexell_ext'][key1].encode('utf-8')
+        self.cmd_param1 = parameters['images']['nexell_ext'][key2].encode('utf-8')
+        self.cmd_param2 = parameters['images']['nexell_ext'][key3].encode('utf-8')
+
+    def validate(self):
+        super(ApplyNexellDeployAction, self).validate()
+        
+    def run(self, connection, args=None):
+        connection = super(ApplyNexellDeployAction, self).run(connection, args)
+        fastboot_cmd = [self.cmd_script, self.cmd_param1, self.cmd_param2]
+        command_output = self.run_command(fastboot_cmd)
+        self.logger.debug("SUKER: fastboot cmd %s", self.cmd_param1)
+
+        # if type(command_output) == bool :
+        #     self.logger.debug("SUKER: command_output type %s", type(command_output))
+        # else :
+        #     if command_output and 'error' in command_output:
+        #         raise JobError("Unable to apply ptable image using fastboot: %s" %
+        #                        command_output)  # FIXME: JobError needs a unit test
+
+        return connection
+
+
+class ApplyNexellAfterDeployAction(DeployAction):
+    def __init__(self,parameters,key):
+        super(ApplyNexellAfterDeployAction, self).__init__()
+        self.name = "fastboot_apply_nexell_action_after_deploy"
+        self.description = "fastboot apply nexell image"
+        self.summary = "fastboot apply nexell"
+        self.retries = 1
+        self.sleep = 5
+        self.cmd = parameters['images']['nexell_ext'][key]
+        self.key = key
+
+    def validate(self):
+        super(ApplyNexellAfterDeployAction, self).validate()
+
+    def run(self, connection, args=None):
+        connection = super(ApplyNexellAfterDeployAction, self).run(connection, args)
+        cmd = ['echo', self.cmd]
+        command_output = self.run_command(cmd, True)
+        
+        return connection
 
 
 class EnterFastbootAction(DeployAction):
@@ -179,50 +276,39 @@ class EnterFastbootAction(DeployAction):
             self.errors = "device fastboot serial number missing"
             if self.job.device['fastboot_serial_number'] == '0000000000':
                 self.errors = "device fastboot serial number unset"
-        if 'fastboot_options' not in self.job.device:
-            self.errors = "device fastboot options missing"
-            if not isinstance(self.job.device['fastboot_options'], list):
-                self.errors = "device fastboot options is not a list"
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(EnterFastbootAction, self).run(connection, max_end_time, args)
-        # this is the device namespace - the lxc namespace is not accessible
-        lxc_name = None
-        protocol = [protocol for protocol in self.job.protocols if protocol.name == LxcProtocol.name][0]
-        if protocol:
-            lxc_name = protocol.lxc_name
-        if not lxc_name:
-            self.errors = "Unable to use fastboot"
-            return connection
-        self.logger.debug("[%s] lxc name: %s", self.parameters['namespace'], lxc_name)
+
+    def run(self, connection, args=None):
+        connection = super(EnterFastbootAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
         fastboot_serial_number = self.job.device['fastboot_serial_number']
 
         # Try to enter fastboot mode with adb.
         adb_serial_number = self.job.device['adb_serial_number']
         adb_cmd = ['lxc-attach', '-n', lxc_name, '--', 'adb', '-s',
                    adb_serial_number, 'devices']
-        command_output = self.run_command(adb_cmd, allow_fail=True)
+        command_output = self.run_command(adb_cmd)
         if command_output and adb_serial_number in command_output:
             self.logger.debug("Device is in adb: %s", command_output)
             adb_cmd = ['lxc-attach', '-n', lxc_name, '--', 'adb',
                        '-s', adb_serial_number, 'reboot-bootloader']
-            self.run_command(adb_cmd)
+            command_output = self.run_command(adb_cmd)
+            if command_output and 'error' in command_output:
+                raise JobError("Unable to enter fastboot: %s" %
+                               command_output)  # FIXME: JobError needs a unit test
             return connection
 
         # Enter fastboot mode with fastboot.
-        fastboot_opts = self.job.device['fastboot_options']
         fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot', '-s',
-                        fastboot_serial_number, 'devices'] + fastboot_opts
+                        fastboot_serial_number, 'devices']
         command_output = self.run_command(fastboot_cmd)
         if command_output and fastboot_serial_number in command_output:
             self.logger.debug("Device is in fastboot: %s", command_output)
             fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
-                            '-s', fastboot_serial_number,
-                            'reboot-bootloader'] + fastboot_opts
+                            '-s', fastboot_serial_number, 'reboot-bootloader']
             command_output = self.run_command(fastboot_cmd)
             if command_output and 'OKAY' not in command_output:
-                raise InfrastructureError("Unable to enter fastboot: %s" %
-                                          command_output)
+                raise JobError("Unable to enter fastboot: %s" %
+                               command_output)  # FIXME: JobError needs a unit test
             else:
                 status = [status.strip() for status in command_output.split(
                     '\n') if 'finished' in status][0]
@@ -230,65 +316,307 @@ class EnterFastbootAction(DeployAction):
         return connection
 
 
-class FastbootFlashAction(DeployAction):
+class FastbootUpdateAction(DeployAction):
     """
-    Fastboot flash image.
+    Fastboot update image.
     """
 
     def __init__(self):
-        super(FastbootFlashAction, self).__init__()
-        self.name = "fastboot_flash_action"
-        self.description = "fastboot_flash"
-        self.summary = "fastboot flash"
+        super(FastbootUpdateAction, self).__init__()
+        self.name = "fastboot_update_action"
+        self.description = "fastboot update image"
+        self.summary = "fastboot update"
         self.retries = 3
         self.sleep = 10
 
     def validate(self):
-        super(FastbootFlashAction, self).validate()
+        super(FastbootUpdateAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['image']:
+            self.errors = "no file specified for fastboot"
         if 'fastboot_serial_number' not in self.job.device:
             self.errors = "device fastboot serial number missing"
             if self.job.device['fastboot_serial_number'] == '0000000000':
                 self.errors = "device fastboot serial number unset"
-        if 'flash_cmds_order' not in self.job.device:
-            self.errors = "device flash commands order missing"
-        if 'fastboot_options' not in self.job.device:
-            self.errors = "device fastboot options missing"
-            if not isinstance(self.job.device['fastboot_options'], list):
-                self.errors = "device fastboot options is not a list"
-
-    def run(self, connection, max_end_time, args=None):  # pylint: disable=too-many-locals
-        connection = super(FastbootFlashAction, self).run(connection, max_end_time, args)
-        # this is the device namespace - the lxc namespace is not accessible
-        lxc_name = None
-        protocol = [protocol for protocol in self.job.protocols if protocol.name == LxcProtocol.name][0]
-        if protocol:
-            lxc_name = protocol.lxc_name
-        if not lxc_name:
-            self.errors = "Unable to use fastboot"
-            return connection
-        # Order flash commands so that some commands take priority over others
-        flash_cmds_order = self.job.device['flash_cmds_order']
-        namespace = self.parameters.get('namespace', 'common')
-        flash_cmds = set(self.data[namespace]['download_action'].keys()).difference(
-            set(flash_cmds_order))
-        flash_cmds = flash_cmds_order + list(flash_cmds)
-
-        for flash_cmd in flash_cmds:
-            src = self.get_namespace_data(action='download_action', label=flash_cmd, key='file')
-            if not src:
-                continue
-            dst = copy_to_lxc(lxc_name, src)
-            sequence = self.job.device['actions']['boot']['methods'].get(
-                'fastboot', [])
-            if 'boot' in sequence and flash_cmd in ['boot']:
-                continue
-            serial_number = self.job.device['fastboot_serial_number']
-            fastboot_opts = self.job.device['fastboot_options']
-            fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
-                            '-s', serial_number, 'flash', flash_cmd,
-                            dst] + fastboot_opts
-            command_output = self.run_command(fastboot_cmd)
-            if command_output and 'error' in command_output:
-                raise InfrastructureError("Unable to flash %s using fastboot: %s" %
-                                          (flash_cmd, command_output))
+
+    def run(self, connection, args=None):
+        connection = super(FastbootUpdateAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['image']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, '-w', 'update', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to update image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class FastbootRebootAction(DeployAction):
+    """
+    Fastboot Reboot.
+    """
+
+    def __init__(self):
+        super(FastbootRebootAction, self).__init__()
+        self.name = "fastboot_reboot_action"
+        self.description = "fastboot reboot"
+        self.summary = "fastboot reboot"
+        self.retries = 3
+        self.sleep = FASTBOOT_REBOOT_TIMEOUT
+
+    def validate(self):
+        super(FastbootRebootAction, self).validate()
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(FastbootRebootAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'reboot']
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to reboot using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplyPtableAction(DeployAction):
+    """
+    Fastboot deploy ptable image.
+    """
+
+    def __init__(self):
+        super(ApplyPtableAction, self).__init__()
+        self.name = "fastboot_apply_ptable_action"
+        self.description = "fastboot apply ptable image"
+        self.summary = "fastboot apply ptable"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplyPtableAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['ptable']:
+            self.errors = "no file specified for fastboot ptable image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplyPtableAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['ptable']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'ptable', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply ptable image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplyBootAction(DeployAction):
+    """
+    Fastboot deploy boot image.
+    """
+
+    def __init__(self):
+        super(ApplyBootAction, self).__init__()
+        self.name = "fastboot_apply_boot_action"
+        self.description = "fastboot apply boot image"
+        self.summary = "fastboot apply boot"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplyBootAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['boot']:
+            self.errors = "no file specified for fastboot boot image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplyBootAction, self).run(connection, args)
+        serial_number = self.job.device['fastboot_serial_number']
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['boot']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'boot', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply boot image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplyCacheAction(DeployAction):
+    """
+    Fastboot deploy cache image.
+    """
+
+    def __init__(self):
+        super(ApplyCacheAction, self).__init__()
+        self.name = "fastboot_apply_cache_action"
+        self.description = "fastboot apply cache image"
+        self.summary = "fastboot apply cache"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplyCacheAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['cache']:
+            self.errors = "no file specified for fastboot cache image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplyCacheAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['cache']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'cache', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply cache image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplyUserdataAction(DeployAction):
+    """
+    Fastboot deploy userdata image.
+    """
+
+    def __init__(self):
+        super(ApplyUserdataAction, self).__init__()
+        self.name = "fastboot_apply_userdata_action"
+        self.description = "fastboot apply userdata image"
+        self.summary = "fastboot apply userdata"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplyUserdataAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['userdata']:
+            self.errors = "no file specified for fastboot userdata image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplyUserdataAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['userdata']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'userdata', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply userdata image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplySystemAction(DeployAction):
+    """
+    Fastboot deploy system image.
+    """
+
+    def __init__(self):
+        super(ApplySystemAction, self).__init__()
+        self.name = "fastboot_apply_system_action"
+        self.description = "fastboot apply system image"
+        self.summary = "fastboot apply system"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplySystemAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['system']:
+            self.errors = "no file specified for fastboot system image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplySystemAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['system']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'system', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply system image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
+        return connection
+
+
+class ApplyVendorAction(DeployAction):
+    """
+    Fastboot deploy vendor image.
+    """
+
+    def __init__(self):
+        super(ApplyVendorAction, self).__init__()
+        self.name = "fastboot_apply_vendor_action"
+        self.description = "fastboot apply vendor image"
+        self.summary = "fastboot apply vendor"
+        self.retries = 3
+        self.sleep = 10
+
+    def validate(self):
+        super(ApplyVendorAction, self).validate()
+        if 'download_action' not in self.data:
+            raise RuntimeError("download-action missing: %s" % self.name)
+        if 'file' not in self.data['download_action']['vendor']:
+            self.errors = "no file specified for fastboot vendor image"
+        if 'fastboot_serial_number' not in self.job.device:
+            self.errors = "device fastboot serial number missing"
+            if self.job.device['fastboot_serial_number'] == '0000000000':
+                self.errors = "device fastboot serial number unset"
+
+    def run(self, connection, args=None):
+        connection = super(ApplyVendorAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        src = self.data['download_action']['vendor']['file']
+        dst = copy_to_lxc(lxc_name, src)
+        serial_number = self.job.device['fastboot_serial_number']
+        fastboot_cmd = ['lxc-attach', '-n', lxc_name, '--', 'fastboot',
+                        '-s', serial_number, 'flash', 'vendor', dst]
+        command_output = self.run_command(fastboot_cmd)
+        if command_output and 'error' in command_output:
+            raise JobError("Unable to apply vendor image using fastboot: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
         return connection
diff --git a/lava_dispatcher/pipeline/actions/deploy/lxc.py b/lava_dispatcher/pipeline/actions/deploy/lxc.py
index 5f7e853..471dd87 100644
--- a/lava_dispatcher/pipeline/actions/deploy/lxc.py
+++ b/lava_dispatcher/pipeline/actions/deploy/lxc.py
@@ -19,32 +19,24 @@
 # with this program; if not, see <http://www.gnu.org/licenses>.
 
 import os
+from time import sleep
 from lava_dispatcher.pipeline.logical import Deployment
 from lava_dispatcher.pipeline.action import (
     Action,
-    ConfigurationError,
-    InfrastructureError,
-    JobError,
-    LAVABug,
     Pipeline,
+    JobError,
 )
 from lava_dispatcher.pipeline.actions.deploy import DeployAction
 from lava_dispatcher.pipeline.actions.deploy.overlay import OverlayAction
 from lava_dispatcher.pipeline.actions.deploy.apply_overlay import ApplyLxcOverlay
-from lava_dispatcher.pipeline.actions.deploy.environment import DeployDeviceEnvironment
-from lava_dispatcher.pipeline.actions.boot.lxc import (
-    LxcStartAction,
-    LxcStopAction,
-)
+# Nexell extension
+from lava_dispatcher.pipeline.actions.deploy.apply_overlay import ApplyNexellOverlay
 from lava_dispatcher.pipeline.utils.shell import infrastructure_error
 from lava_dispatcher.pipeline.protocols.lxc import LxcProtocol
 from lava_dispatcher.pipeline.utils.constants import (
     LXC_TEMPLATE_WITH_MIRROR,
+    USB_SHOW_UP_TIMEOUT,
 )
-from lava_dispatcher.pipeline.utils.udev import get_usb_devices
-from lava_dispatcher.pipeline.utils.filesystem import debian_package_version
-
-# pylint: disable=superfluous-parens
 
 
 def lxc_accept(device, parameters):
@@ -61,11 +53,11 @@ def lxc_accept(device, parameters):
     if not device:
         return False
     if 'actions' not in device:
-        raise ConfigurationError("Invalid device configuration")
+        raise RuntimeError("Invalid device configuration")
     if 'deploy' not in device['actions']:
         return False
     if 'methods' not in device['actions']['deploy']:
-        raise ConfigurationError("Device misconfiguration")
+        raise RuntimeError("Device misconfiguration")
     return True
 
 
@@ -103,31 +95,54 @@ class LxcAction(DeployAction):  # pylint:disable=too-many-instance-attributes
 
     def validate(self):
         super(LxcAction, self).validate()
-        self.logger.info("lxc, installed at version: %s" %
-                         debian_package_version(pkg='lxc', split=False))
         if LxcProtocol.name not in [protocol.name for protocol in self.job.protocols]:
             self.errors = "Invalid job - missing protocol"
         self.errors = infrastructure_error('lxc-create')
         lava_test_results_dir = self.parameters['deployment_data']['lava_test_results_dir']
         lava_test_results_dir = lava_test_results_dir % self.job.job_id
-        self.set_namespace_data(action='test', label='results', key='lava_test_results_dir', value=lava_test_results_dir)
-        lava_test_sh_cmd = self.parameters['deployment_data']['lava_test_sh_cmd']
-        self.set_namespace_data(action=self.name, label='shared', key='lava_test_sh_cmd', value=lava_test_sh_cmd)
+        self.data['lava_test_results_dir'] = lava_test_results_dir
+        namespace = self.parameters.get('namespace', None)
+        if namespace:
+            self.action_namespaces.append(namespace)
+            self.set_common_data(namespace, 'lava_test_results_dir',
+                                 lava_test_results_dir)
+            lava_test_sh_cmd = self.parameters['deployment_data']['lava_test_sh_cmd']
+            self.set_common_data(namespace, 'lava_test_sh_cmd',
+                                 lava_test_sh_cmd)
 
     def populate(self, parameters):
         self.internal_pipeline = Pipeline(parent=self, job=self.job,
                                           parameters=parameters)
-        self.internal_pipeline.add_action(LxcCreateAction())
-        if 'packages' in parameters:
-            self.internal_pipeline.add_action(LxcStartAction())
-            self.internal_pipeline.add_action(LxcAptUpdateAction())
-            self.internal_pipeline.add_action(LxcAptInstallAction())
-            self.internal_pipeline.add_action(LxcStopAction())
-        # needed if export device environment is also to be used
-        self.internal_pipeline.add_action(DeployDeviceEnvironment())
-        self.internal_pipeline.add_action(OverlayAction())
-        self.internal_pipeline.add_action(ApplyLxcOverlay())
+        if parameters['nexell_ext']:
+            self.internal_pipeline.add_action(NexellCreateAction())
+            self.internal_pipeline.add_action(OverlayAction())
+            self.internal_pipeline.add_action(ApplyNexellOverlay())
+        else :
+            self.internal_pipeline.add_action(LxcCreateAction())
+            self.internal_pipeline.add_action(OverlayAction())
+            self.internal_pipeline.add_action(ApplyLxcOverlay())
+
+class NexellCreateAction(DeployAction):
+    """
+    Creates Lxc container.
+    """
+
+    def __init__(self):
+        super(NexellCreateAction, self).__init__()
+        self.name = "Nexell-create-action"
+        self.description = "create action"
+        self.summary = "create Nexell connection"
+        self.retries = 10
+        self.sleep = 10
+        self.lxc_data = {}
 
+    def validate(self):
+        super(NexellCreateAction, self).validate()
+
+    def run(self, connection, args=None):
+        connection = super(NexellCreateAction, self).run(connection, args)
+        self.results = {'status': 'success'}
+        return connection
 
 class LxcCreateAction(DeployAction):
     """
@@ -148,7 +163,7 @@ class LxcCreateAction(DeployAction):
                      if protocol.name == LxcProtocol.name]
         if protocols:
             protocol = protocols[0]
-            self.set_namespace_data(action=self.name, label='lxc', key='name', value=protocol.lxc_name)
+            self.set_common_data('lxc', 'name', protocol.lxc_name)
             self.lxc_data['lxc_name'] = protocol.lxc_name
             self.lxc_data['lxc_distribution'] = protocol.lxc_dist
             self.lxc_data['lxc_release'] = protocol.lxc_release
@@ -156,20 +171,17 @@ class LxcCreateAction(DeployAction):
             self.lxc_data['lxc_template'] = protocol.lxc_template
             self.lxc_data['lxc_mirror'] = protocol.lxc_mirror
             self.lxc_data['lxc_security_mirror'] = protocol.lxc_security_mirror
-            self.lxc_data['verbose'] = protocol.verbose
 
     def validate(self):
         super(LxcCreateAction, self).validate()
         # set lxc_data
         self._set_lxc_data()
 
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcCreateAction, self).run(connection, max_end_time, args)
-        verbose = '' if self.lxc_data['verbose'] else '-q'
+    def run(self, connection, args=None):
+        connection = super(LxcCreateAction, self).run(connection, args)
         if self.lxc_data['lxc_template'] in LXC_TEMPLATE_WITH_MIRROR:
-            lxc_cmd = ['lxc-create', verbose, '-t',
-                       self.lxc_data['lxc_template'], '-n',
-                       self.lxc_data['lxc_name'], '--', '--release',
+            lxc_cmd = ['lxc-create', '-t', self.lxc_data['lxc_template'],
+                       '-n', self.lxc_data['lxc_name'], '--', '--release',
                        self.lxc_data['lxc_release'], '--arch',
                        self.lxc_data['lxc_arch']]
             if self.lxc_data['lxc_mirror']:
@@ -177,78 +189,26 @@ class LxcCreateAction(DeployAction):
             if self.lxc_data['lxc_security_mirror']:
                 lxc_cmd += ['--security-mirror',
                             self.lxc_data['lxc_security_mirror']]
-            # FIXME: Should be removed when LAVA's supported distro is bumped
-            #        to Debian Stretch or any distro that supports systemd
-            lxc_cmd += ['--packages', 'systemd,systemd-sysv']
+            if 'packages' in self.parameters:
+                lxc_cmd += ['--packages',
+                            ','.join(self.parameters['packages'])]
+            cmd_out_str = 'Generation complete.'
         else:
-            lxc_cmd = ['lxc-create', verbose, '-t',
-                       self.lxc_data['lxc_template'], '-n',
-                       self.lxc_data['lxc_name'], '--', '--dist',
+            lxc_cmd = ['lxc-create', '-t', self.lxc_data['lxc_template'],
+                       '-n', self.lxc_data['lxc_name'], '--', '--dist',
                        self.lxc_data['lxc_distribution'], '--release',
                        self.lxc_data['lxc_release'], '--arch',
                        self.lxc_data['lxc_arch']]
-        if not self.run_command(lxc_cmd, allow_silent=True):
-            raise InfrastructureError("Unable to create lxc container")
+            cmd_out_str = 'Unpacking the rootfs'
+        command_output = self.run_command(lxc_cmd)
+        if command_output and cmd_out_str not in command_output:
+            raise JobError("Unable to create lxc container: %s" %
+                           command_output)  # FIXME: JobError needs a unit test
         else:
             self.results = {'status': self.lxc_data['lxc_name']}
         return connection
 
 
-class LxcAptUpdateAction(DeployAction):
-    """
-    apt-get update the lxc container.
-    """
-
-    def __init__(self):
-        super(LxcAptUpdateAction, self).__init__()
-        self.name = "lxc-apt-update"
-        self.description = "lxc apt update action"
-        self.summary = "lxc apt update"
-        self.retries = 10
-        self.sleep = 10
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcAptUpdateAction, self).run(connection,
-                                                         max_end_time, args)
-        lxc_name = self.get_namespace_data(action='lxc-create-action',
-                                           label='lxc', key='name')
-        cmd = ['lxc-attach', '-n', lxc_name, '--', 'apt-get', '-y', 'update']
-        if not self.run_command(cmd, allow_silent=True):
-            raise JobError("Unable to apt-get update in lxc container")
-        return connection
-
-
-class LxcAptInstallAction(DeployAction):
-    """
-    apt-get install packages to the lxc container.
-    """
-
-    def __init__(self):
-        super(LxcAptInstallAction, self).__init__()
-        self.name = "lxc-apt-install"
-        self.description = "lxc apt install packages action"
-        self.summary = "lxc apt install"
-        self.retries = 10
-        self.sleep = 10
-
-    def validate(self):
-        super(LxcAptInstallAction, self).validate()
-        if 'packages' not in self.parameters:
-            raise LAVABug("%s package list unavailable" % self.name)
-
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcAptInstallAction, self).run(connection,
-                                                          max_end_time, args)
-        lxc_name = self.get_namespace_data(action='lxc-create-action',
-                                           label='lxc', key='name')
-        packages = self.parameters['packages']
-        cmd = ['lxc-attach', '-n', lxc_name, '--', 'apt-get', '-y',
-               'install'] + packages
-        if not self.run_command(cmd):
-            raise JobError("Unable to install using apt-get in lxc container")
-        return connection
-
-
 class LxcAddDeviceAction(Action):
     """Add usb device to lxc.
     """
@@ -262,42 +222,33 @@ class LxcAddDeviceAction(Action):
 
     def validate(self):
         super(LxcAddDeviceAction, self).validate()
-        if 'device_info' in self.job.device \
-           and not isinstance(self.job.device.get('device_info'), list):
-            self.errors = "device_info unset"
-        try:
-            if 'device_info' in self.job.device:
-                for usb_device in self.job.device['device_info']:
-                    board_id = usb_device.get('board_id', '')
-                    usb_vendor_id = usb_device.get('usb_vendor_id', '')
-                    usb_product_id = usb_device.get('usb_product_id', '')
-                    if board_id == '0000000000':
-                        self.errors = "board_id unset"
-                    if usb_vendor_id == '0000':
-                        self.errors = 'usb_vendor_id unset'
-                    if usb_product_id == '0000':
-                        self.errors = 'usb_product_id unset'
-        except TypeError:
-            self.errors = "Invalid parameters for %s" % self.name
 
-    def run(self, connection, max_end_time, args=None):
-        connection = super(LxcAddDeviceAction, self).run(connection, max_end_time, args)
-        # this is the device namespace - the lxc namespace is not accessible
-        lxc_name = None
-        protocol = [protocol for protocol in self.job.protocols if protocol.name == LxcProtocol.name][0]
-        if protocol:
-            lxc_name = protocol.lxc_name
-        if not lxc_name:
-            self.logger.debug("No LXC device requested")
-            self.errors = "Unable to use fastboot"
-            return connection
-
-        self.logger.info("Get USB device(s) ...")
-        device_paths = get_usb_devices(self.job)
-        for device in device_paths:
-            lxc_cmd = ['lxc-device', '-n', lxc_name, 'add',
-                       os.path.realpath(device)]
-            log = self.run_command(lxc_cmd)
-            self.logger.debug(log)
-            self.logger.debug("%s: device %s added", lxc_name, device)
-        return connection
+    def run(self, connection, args=None):
+        connection = super(LxcAddDeviceAction, self).run(connection, args)
+        lxc_name = self.get_common_data('lxc', 'name')
+        if 'device_path' in list(self.job.device.keys()):
+            device_path = self.job.device['device_path']
+            if not isinstance(device_path, list):
+                raise JobError("device_path should be a list")
+
+            if device_path:
+                # Wait USB_SHOW_UP_TIMEOUT seconds for usb device to show up
+                self.logger.info("Wait %d seconds for usb device to show up",
+                                 USB_SHOW_UP_TIMEOUT)
+                sleep(USB_SHOW_UP_TIMEOUT)
+
+                for path in device_path:
+                    path = os.path.realpath(path)
+                    if os.path.isdir(path):
+                        devices = os.listdir(path)
+                    else:
+                        devices = [path]
+
+                    for device in devices:
+                        device = os.path.join(path, device)
+                        lxc_cmd = ['lxc-device', '-n', lxc_name, 'add', device]
+                        self.run_command(lxc_cmd)
+                        self.logger.debug("%s: devices added from %s", lxc_name,
+                                          path)
+            else:
+                self.logger.debug("device_path is None")
diff --git a/lava_dispatcher/pipeline/connections/lxc.py b/lava_dispatcher/pipeline/connections/lxc.py
index ce53ca1..ad61573 100644
--- a/lava_dispatcher/pipeline/connections/lxc.py
+++ b/lava_dispatcher/pipeline/connections/lxc.py
@@ -19,13 +19,15 @@
 # with this program; if not, see <http://www.gnu.org/licenses>.
 
 import os
+import signal
+from time import sleep
 from lava_dispatcher.pipeline.utils.shell import infrastructure_error
 from lava_dispatcher.pipeline.action import (
     Action,
     JobError,
 )
 from lava_dispatcher.pipeline.shell import ShellCommand, ShellSession
-from lava_dispatcher.pipeline.utils.udev import get_usb_devices
+from lava_dispatcher.pipeline.utils.constants import USB_SHOW_UP_TIMEOUT
 
 # pylint: disable=too-many-public-methods
 
@@ -43,36 +45,107 @@ class ConnectLxc(Action):
         self.shell_class = ShellCommand
 
     def validate(self):
-        if 'lxc' not in self.job.device['actions']['boot']['methods']:
-            return
         super(ConnectLxc, self).validate()
         self.errors = infrastructure_error('lxc-attach')
+        if 'prompts' not in self.parameters:
+            self.errors = "Unable to identify test image prompts from parameters."
 
-    def run(self, connection, max_end_time, args=None):
-        lxc_name = self.get_namespace_data(
-            action='lxc-create-action',
-            label='lxc',
-            key='name'
-        )
-        if not lxc_name:
-            self.logger.debug("No LXC device requested")
-            return connection
-
-        self.logger.info("Get USB device(s) ...")
-        device_paths = get_usb_devices(self.job)
-        for device in device_paths:
-            lxc_cmd = ['lxc-device', '-n', lxc_name, 'add',
-                       os.path.realpath(device)]
-            log = self.run_command(lxc_cmd)
-            self.logger.debug(log)
-            self.logger.debug("%s: device %s added", lxc_name, device)
-
-        connection = self.get_namespace_data(action='shared', label='shared', key='connection', deepcopy=False)
-        if connection:
-            return connection
+    def run(self, connection, args=None):
+        lxc_name = self.get_common_data('lxc', 'name')
+
+        # Attach usb device to lxc
+        if 'device_path' in list(self.job.device.keys()):
+            device_path = self.job.device['device_path']
+            if not isinstance(device_path, list):
+                raise JobError("device_path should be a list")
+
+            if device_path:
+                # Wait USB_SHOW_UP_TIMEOUT seconds for usb device to show up
+                self.logger.info("Wait %d seconds for usb device to show up",
+                                 USB_SHOW_UP_TIMEOUT)
+                sleep(USB_SHOW_UP_TIMEOUT)
+
+                for path in device_path:
+                    path = os.path.realpath(path)
+                    if os.path.isdir(path):
+                        devices = os.listdir(path)
+                    else:
+                        devices = [path]
+
+                    for device in devices:
+                        device = os.path.join(path, device)
+                        lxc_cmd = ['lxc-device', '-n', lxc_name, 'add', device]
+                        self.run_command(lxc_cmd)
+                        self.logger.debug("%s: devices added from %s", lxc_name,
+                                          path)
+            else:
+                self.logger.debug("device_path is None")
 
         cmd = "lxc-attach -n {0}".format(lxc_name)
         self.logger.info("%s Connecting to device using '%s'", self.name, cmd)
+        signal.alarm(0)  # clear the timeouts used without connections.
+        # ShellCommand executes the connection command
+        shell = self.shell_class("%s\n" % cmd, self.timeout,
+                                 logger=self.logger)
+        if shell.exitstatus:
+            raise JobError("%s command exited %d: %s" % (cmd,
+                                                         shell.exitstatus,
+                                                         shell.readlines()))
+        # ShellSession monitors the pexpect
+        connection = self.session_class(self.job, shell)
+        connection.connected = True
+        connection = super(ConnectLxc, self).run(connection, args)
+        connection.prompt_str = self.parameters['prompts']
+        self.data['boot-result'] = 'failed' if self.errors else 'success'
+        return connection
+
+# Nexell extension
+class ConnectNexell(Action):
+    """
+    Class to make a lxc shell connection to the container.
+    """
+    def __init__(self):
+        super(ConnectNexell, self).__init__()
+        self.name = "connect-nexell-device"
+        self.summary = "run connection command"
+        self.description = "connect to the nexell device"
+        self.session_class = ShellSession
+        self.shell_class = ShellCommand
+
+    def validate(self):
+        super(ConnectNexell, self).validate()
+
+    def run(self, connection, args=None):
+        # Attach usb device to lxc
+        if 'device_path' in list(self.job.device.keys()):
+            device_path = self.job.device['device_path']
+            if not isinstance(device_path, list):
+                raise JobError("device_path should be a list")
+
+            if device_path:
+                # Wait USB_SHOW_UP_TIMEOUT seconds for usb device to show up
+                self.logger.info("Wait %d seconds for usb device to show up",
+                                 USB_SHOW_UP_TIMEOUT)
+                sleep(USB_SHOW_UP_TIMEOUT)
+                # for path in device_path:
+                #     path = os.path.realpath(path)
+                #     if os.path.isdir(path):
+                #         devices = os.listdir(path)
+                #     else:
+                #         devices = [path]
+
+                #     for device in devices:
+                #         device = os.path.join(path, device)
+                #         lxc_cmd = ['lxc-device', '-n', lxc_name, 'add', device]
+                #         self.run_command(lxc_cmd)
+                #         self.logger.debug("%s: devices added from %s", lxc_name,
+                #                           path)
+            else:
+                self.logger.debug("device_path is None")
+
+        cmd = str(self.parameters['nexell_ext']['cmd']) + ' ' + str(self.parameters['nexell_ext']['param'])
+        self.logger.info("%s Connecting to device using '%s'", self.name, cmd)
+        signal.alarm(0)  # clear the timeouts used without connections.
         # ShellCommand executes the connection command
         shell = self.shell_class("%s\n" % cmd, self.timeout,
                                  logger=self.logger)
@@ -83,9 +156,7 @@ class ConnectLxc(Action):
         # ShellSession monitors the pexpect
         connection = self.session_class(self.job, shell)
         connection.connected = True
-        connection = super(ConnectLxc, self).run(connection, max_end_time, args)
+        connection = super(ConnectNexell, self).run(connection, args)
         connection.prompt_str = self.parameters['prompts']
-        res = 'failed' if self.errors else 'success'
-        self.set_namespace_data(action='boot', label='shared', key='boot-result', value=res)
-        self.set_namespace_data(action='shared', label='shared', key='connection', value=connection)
+        self.data['boot-result'] = 'failed' if self.errors else 'success'
         return connection
diff --git a/lava_dispatcher/pipeline/connections/telnet.py b/lava_dispatcher/pipeline/connections/telnet.py
new file mode 100644
index 0000000..475ba3b
--- /dev/null
+++ b/lava_dispatcher/pipeline/connections/telnet.py
@@ -0,0 +1,94 @@
+# Copyright (C) 2016 Linaro Limited
+#
+# Author: Senthil Kumaran S <senthil.kumaran@linaro.org>
+#
+# This file is part of LAVA Dispatcher.
+#
+# LAVA Dispatcher is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# LAVA Dispatcher is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along
+# with this program; if not, see <http://www.gnu.org/licenses>.
+
+import os
+import signal
+from time import sleep
+from lava_dispatcher.pipeline.utils.shell import infrastructure_error
+from lava_dispatcher.pipeline.action import (
+    Action,
+    JobError,
+)
+from lava_dispatcher.pipeline.shell import ShellCommand, ShellSession
+from lava_dispatcher.pipeline.utils.constants import USB_SHOW_UP_TIMEOUT
+
+# pylint: disable=too-many-public-methods
+
+
+class ConnectTelnet(Action):
+    """
+    Class to make a telnet shell connection
+    """
+    def __init__(self,parameters):
+        super(ConnectTelnet, self).__init__()
+        self.name = "connect-telnet"
+        self.summary = "run connection command"
+        self.description = "connect to the telnet container"
+        self.session_class = ShellSession
+        self.shell_class = ShellCommand
+        self.params = parameters
+        
+    def validate(self):
+        super(ConnectTelnet, self).validate()
+        self.errors = infrastructure_error('telnet')
+        if 'prompts' not in self.parameters:
+            self.errors = "Unable to identify test image prompts from parameters."
+
+    def run(self, connection, args=None):
+        self.logger.debug("SUKER: connection/telnet.py: " + str(self.parameters))
+
+        # Attach usb device to telnet
+        if 'device_path' in list(self.job.device.keys()):
+            device_path = self.job.device['device_path']
+            if not isinstance(device_path, list):
+                raise JobError("device_path should be a list")
+
+            if device_path:
+                # Wait USB_SHOW_UP_TIMEOUT seconds for usb device to show up
+                self.logger.info("Wait %d seconds for usb device to show up",
+                                 USB_SHOW_UP_TIMEOUT)
+                sleep(USB_SHOW_UP_TIMEOUT)
+
+                for path in device_path:
+                    path = os.path.realpath(path)
+                    if os.path.isdir(path):
+                        devices = os.listdir(path)
+                    else:
+                        devices = [path]
+            else:
+                self.logger.debug("device_path is None")
+
+        cmd = "telnet localhost 4001"
+        self.logger.info("%s Connecting to device using '%s'", self.name, cmd)
+        signal.alarm(0)  # clear the timeouts used without connections.
+        # ShellCommand executes the connection command
+        shell = self.shell_class("%s\n" % cmd, self.timeout,
+                                 logger=self.logger)
+        if shell.exitstatus:
+            raise JobError("%s command exited %d: %s" % (cmd,
+                                                         shell.exitstatus,
+                                                         shell.readlines()))
+        # ShellSession monitors the pexpect
+        connection = self.session_class(self.job, shell)
+        connection.connected = True
+        connection = super(ConnectTelnet, self).run(connection, args)
+        connection.prompt_str = self.parameters['prompts']
+        self.data['boot-result'] = 'failed' if self.errors else 'success'
+        return connection
diff --git a/lava_dispatcher/pipeline/protocols/lxc.py b/lava_dispatcher/pipeline/protocols/lxc.py
index d125a19..7e3bff3 100644
--- a/lava_dispatcher/pipeline/protocols/lxc.py
+++ b/lava_dispatcher/pipeline/protocols/lxc.py
@@ -23,8 +23,8 @@ import pexpect
 import logging
 from lava_dispatcher.pipeline.connection import Protocol
 from lava_dispatcher.pipeline.action import (
-    InfrastructureError,
     Timeout,
+    JobError,
 )
 from lava_dispatcher.pipeline.shell import ShellCommand
 from lava_dispatcher.pipeline.utils.constants import LAVA_LXC_TIMEOUT
@@ -50,8 +50,6 @@ class LxcProtocol(Protocol):
                                                                  None)
         self.lxc_security_mirror = parameters['protocols'][self.name].get(
             'security_mirror', None)
-        self.verbose = parameters['protocols'][self.name].get('verbose', False)
-        self.fastboot_reboot = parameters.get('reboot_to_fastboot', True)
         self.logger = logging.getLogger('dispatcher')
 
     @classmethod
@@ -80,40 +78,32 @@ class LxcProtocol(Protocol):
         """Called by Finalize action to power down and clean up the assigned
         device.
         """
-        # Reboot devices to bootloader if required, based on the availability
-        # of power cycle option and adb_serial_number.
-        # Do not reboot to bootloader if 'reboot_to_fastboot' is set to
-        # 'false' in job definition.
-        if self.fastboot_reboot:
-            if 'adb_serial_number' in device and hasattr(device, 'power_state'):
-                if device.power_state not in ['on', 'off']:
-                    reboot_cmd = "lxc-attach -n {0} -- adb reboot bootloader".format(self.lxc_name)
-                    self.logger.debug("%s protocol: executing '%s'", self.name,
-                                      reboot_cmd)
-                    shell = ShellCommand("%s\n" % reboot_cmd,
-                                         self.system_timeout,
-                                         logger=self.logger)
-                    # execute the command.
-                    shell.expect(pexpect.EOF)
-                    if shell.exitstatus:
-                        self.logger.debug("%s command exited %d: %s",
-                                          reboot_cmd,
-                                          shell.exitstatus, shell.readlines())
+        # Nexell Extension
+        if 'nexell_command' in device:
+            reboot_cmd = "/home/lava/bin/nexell-lava-commands.sh running"
+            #self.logger.debug("%s protocol: executing '%s'", self.name, reboot_cmd)
+            shell = ShellCommand("%s\n" % reboot_cmd, self.system_timeout, logger=self.logger)
+            # execute the command.
+            shell.expect(pexpect.EOF)
+            self.logger.debug("SUKER: protocols/lxc.py nexell_command run")
+            
         else:
-            self.logger.info("%s protocol: device not rebooting to fastboot",
-                             self.name)
+            # Reboot devices that have adb serial number.
+            if 'adb_serial_number' in device:
+                reboot_cmd = "lxc-attach -n {0} -- adb reboot bootloader".format(
+                    self.lxc_name)
+                self.logger.debug("%s protocol: executing '%s'", self.name,
+                                  reboot_cmd)
+                shell = ShellCommand("%s\n" % reboot_cmd, self.system_timeout,
+                                     logger=self.logger)
+                # execute the command.
+                shell.expect(pexpect.EOF)
+                if shell.exitstatus:
+                    self.logger.debug("%s command exited %d: %s",
+                                      reboot_cmd, shell.exitstatus,
+                                      shell.readlines())
 
-        # ShellCommand executes the destroy command after checking for the
-        # existance of the container
-        cmd = "lxc-info -p -n {0}".format(self.lxc_name)
-        self.logger.debug("%s protocol: executing '%s'", self.name, cmd)
-        shell = ShellCommand("%s\n" % cmd, self.system_timeout,
-                             logger=self.logger)
-        # execute the command.
-        shell.expect(pexpect.EOF)
-        if not shell.exitstatus:
-            self.logger.info("%s protocol: %s exists, proceed to destroy",
-                             self.name, self.lxc_name)
+            # ShellCommand executes the destroy command
             cmd = "lxc-destroy -n {0} -f".format(self.lxc_name)
             self.logger.debug("%s protocol: executing '%s'", self.name, cmd)
             shell = ShellCommand("%s\n" % cmd, self.system_timeout,
@@ -121,7 +111,6 @@ class LxcProtocol(Protocol):
             # execute the command.
             shell.expect(pexpect.EOF)
             if shell.exitstatus:
-                raise InfrastructureError("%s command exited %d: %s" % (cmd,
-                                                                        shell.exitstatus,
-                                                                        shell.readlines()))
-        self.logger.debug("%s protocol finalised.", self.name)
+                raise JobError("%s command exited %d: %s" % (cmd, shell.exitstatus,
+                                                             shell.readlines()))
+            self.logger.debug("%s protocol finalised.", self.name)
diff --git a/lava_dispatcher/pipeline/utils/constants.py b/lava_dispatcher/pipeline/utils/constants.py
index 93d9b9a..804ec8f 100644
--- a/lava_dispatcher/pipeline/utils/constants.py
+++ b/lava_dispatcher/pipeline/utils/constants.py
@@ -23,6 +23,10 @@
 
 # pylint: disable=anomalous-backslash-in-string
 
+# Delay between each character sent to the shell. This is required for some
+# slow serial consoles.
+SHELL_SEND_DELAY = 0.05
+
 # Default timeout for shell operations
 SHELL_DEFAULT_TIMEOUT = 60
 
@@ -35,15 +39,9 @@ MAX_RETRY = 5
 # u-boot auto boot prompt
 UBOOT_AUTOBOOT_PROMPT = "Hit any key to stop autoboot"
 
-# u-boot interrupt character
-UBOOT_INTERRUPT_CHARACTER = ' '
-
 # u-boot default timeout for commands
 UBOOT_DEFAULT_CMD_TIMEOUT = 90
 
-# size of u-boot header to be removed from ramdisks, in bytes.
-UBOOT_DEFAULT_HEADER_LENGTH = 64
-
 # Ramdisk default filenames
 RAMDISK_FNAME = 'ramdisk.cpio'
 
@@ -74,9 +72,6 @@ SHUTDOWN_MESSAGE = 'The system is going down for reboot NOW'
 # Kernel starting message
 BOOT_MESSAGE = 'Booting Linux'
 
-# CPU reset message
-CPU_RESET_MESSAGE = 'Resetting CPU'
-
 # Default shell prompt for AutoLogin
 DEFAULT_SHELL_PROMPT = 'lava-test: # '
 
@@ -93,9 +88,15 @@ ACTION_TIMEOUT = 30
 # Android tmp directory
 ANDROID_TMP_DIR = '/data/local/tmp'
 
+# Default timeout for fastboot reboot
+FASTBOOT_REBOOT_TIMEOUT = 10
+
 # LXC container path
 LXC_PATH = "/var/lib/lxc"
 
+# Nexell extension
+NEXELL_PATH = "/var/lib/nexell"
+
 # LXC finalize timeout
 LAVA_LXC_TIMEOUT = 30
 
@@ -114,6 +115,9 @@ BOOTLOADER_DEFAULT_CMD_TIMEOUT = 90
 
 GRUB_BOOT_PROMPT = "Press enter to boot the selected OS"
 
+# Timeout for USB devices to settle and show up
+USB_SHOW_UP_TIMEOUT = 20
+
 # kernel boot monitoring
 # Some successful kernel builds end the boot with this string
 KERNEL_FREE_UNUSED_MSG = 'Freeing unused kernel memory'
@@ -121,8 +125,6 @@ KERNEL_FREE_UNUSED_MSG = 'Freeing unused kernel memory'
 KERNEL_FREE_INIT_MSG = 'Freeing init memory'
 # exception
 KERNEL_EXCEPTION_MSG = '-+\[ cut here \]-+\s+(.*\s+-+\[ end trace (\w*) \]-+)'
-# stack trace
-KERNEL_TRACE_MSG = 'Stack:\s+(.*\s+-+\[ end trace (\w*) \]-+)'
 # unhandled fault
 KERNEL_FAULT_MSG = '(Unhandled fault.*)\r\n'
 # panic
@@ -130,11 +132,6 @@ KERNEL_PANIC_MSG = "Kernel panic - (.*) end Kernel panic"
 # init dropping to a shell - often needs a sendline
 KERNEL_INIT_ALERT = 'ALERT! .* does not exist.\s+Dropping to a shell!'
 
-# Login incorrect message
-LOGIN_INCORRECT_MSG = 'Login incorrect'
-# Login incorrect message
-LOGIN_TIMED_OUT_MSG = 'Login timed out'
-
 # qemu installer size limit in Mb
 # (i.e. size * 1024 * 1024)
 INSTALLER_IMAGE_MAX_SIZE = 8 * 1024  # 8Gb
@@ -146,24 +143,3 @@ DEFAULT_V1_FIXUP = {'PASS': 'pass', 'FAIL': 'fail', 'SKIP': 'skip', 'UNKNOWN': '
 
 # Message for notifying completion of secondary deployment
 SECONDARY_DEPLOYMENT_MSG = "Secondary media deployment complete"
-
-# fallback UEFI menu label class
-DEFAULT_UEFI_LABEL_CLASS = 'a-zA-Z0-9\s\:'
-
-# Set a default newline seperator for pexpect, override as necessary
-LINE_SEPARATOR = '\n'
-# other newline separators
-UEFI_LINE_SEPARATOR = '\r\n'
-
-# valid characters in components of a test definition name
-# excludes whitespace and punctuation (except hyphen and underscore)
-DEFAULT_TESTDEF_NAME_CLASS = r'^[\w\d\_\-]+$'
-
-# Limit repetitive messages
-METADATA_MESSAGE_LIMIT = 8192
-
-# Versatile Express autorun interrupt character
-VEXPRESS_AUTORUN_INTERRUPT_CHARACTER = ' '
-
-# sys class kvm path
-SYS_CLASS_KVM = '/sys/class/misc/kvm'
-- 
2.7.4

